1. Платформа Java: Java Development Kit (JDK): состав, назначение. Кроссплатформенность языка Java
Java Development Kit (JDK) — это набор инструментов, предоставляемый Oracle Corporation (или другими поставщиками) для разработки, компиляции, отладки и выполнения Java-приложений.
Состав JDK:
1.	Компилятор (javac): переводит исходный Java-код в байт-код, который понимает JVM.
2.	Java Virtual Machine (JVM): исполняет байт-код на целевой платформе.
3.	Библиотеки классов (Java API): предоставляет готовые классы и методы для ускорения разработки.
4.	Инструменты разработки: утилиты для отладки, анализа кода и мониторинга приложений (например, javadoc, jdb, jps).
Назначение JDK:
JDK используется для создания Java-программ. Оно включает в себя все необходимые инструменты для полного цикла разработки: от написания кода до его выполнения и тестирования.
Кроссплатформенность Java:
Java является кроссплатформенным языком благодаря концепции “Write Once, Run Anywhere”. Это достигается за счет JVM, которая интерпретирует байт-код независимо от операционной системы. Единственное условие — наличие соответствующей JVM для целевой платформы.
________________________________________
2. Java Virtual Machine (JVM), JIT-компилятор: определение, свойства, функции. Принципы работы сборщика мусора.
JVM (Java Virtual Machine):
JVM — это виртуальная машина, которая исполняет байт-код Java. Она является основой для кроссплатформенности Java.
Свойства JVM:
1.	Обеспечивает безопасность и изоляцию приложений.
2.	Управляет памятью, используя сборщик мусора (Garbage Collector).
3.	Предоставляет платформенно-независимую среду выполнения.
JIT-компилятор (Just-In-Time):
JIT-компилятор преобразует байт-код в машинный код во время выполнения программы. Это увеличивает производительность, так как машинный код выполняется быстрее интерпретируемого байт-кода.
Принципы работы сборщика мусора:
1.	Обнаружение неиспользуемых объектов: сборщик мусора идентифицирует объекты, которые больше не доступны ни из одного активного потока.
2.	Освобождение памяти: удаляет такие объекты, чтобы освободить память для новых объектов.
3.	Алгоритмы: используются разные подходы, такие как "маркировка и очистка" (Mark-and-Sweep), "копирование" (Copying) или "поколения" (Generational Garbage Collection).
________________________________________
3. Системы сборки проектов. Фреймворк Apache Maven: определение, структура, Maven Coordinates, POM-файл.
Что такое Apache Maven:
Apache Maven — это инструмент для автоматизации сборки проектов на Java. Он используется для управления зависимостями, компиляции кода, тестирования и сборки исполняемых файлов.
Структура Maven:
1.	src/main/java — исходный код.
2.	src/test/java — тесты.
3.	target/ — результирующие артефакты сборки.
Maven Coordinates:
Maven использует координаты для уникальной идентификации артефактов (зависимостей):
•	groupId: идентификатор разработчика или организации.
•	artifactId: название проекта или модуля.
•	version: версия проекта.
POM-файл (Project Object Model):
Это XML-файл, который содержит информацию о проекте и настройках сборки. Пример:
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>my-app</artifactId>
    <version>1.0.0</version>
</project>
________________________________________
4. Типы данных Java: простые и ссылочные. Простые (примитивные) типы данных.
Примитивные типы данных:
1.	Целочисленные: byte, short, int, long.
2.	С плавающей запятой: float, double.
3.	Символьный: char.
4.	Логический: boolean.
Ссылочные типы данных:
Ссылочные типы хранят ссылку на объект в памяти. Примеры: классы, интерфейсы, массивы.
Отличия:
Примитивные типы хранят значение непосредственно, а ссылочные — ссылку на объект в памяти.
________________________________________
5. Переменные: статические и нестатические. Местные переменные, область видимости переменных. Объявление и инициализация переменных. Константы. Спецификаторы доступа.
Статические переменные:
Принадлежат классу и разделяются между всеми объектами.
Нестатические переменные:
Уникальны для каждого объекта.
Местные переменные:
Объявляются внутри метода и доступны только в его пределах.
Константы:
Объявляются с помощью final. Их значение нельзя изменить после инициализации.
Спецификаторы доступа:
1.	public — доступ из любого места.
2.	private — доступ только внутри класса.
3.	protected — доступ из класса и его подклассов.
4.	default (без спецификатора) — доступ в пределах пакета.
________________________________________
6. Комментарии: виды, особенности применения.
Типы комментариев:
1.	Однострочные: начинаются с //.
2.	Многострочные: выделяются с помощью /* */.
3.	Документирующие: используются с /** */ для генерации JavaDoc.
Применение:
Комментарии используются для пояснения кода, увеличения его читаемости и генерации документации.
________________________________________
7. Операции языка Java: арифметические, отношения и логические, преобразования числовых типов.
Арифметические операции:
1.	Сложение (+): складывает два числа.
2.	Вычитание (-): вычитает одно число из другого.
3.	Умножение (*): перемножает два числа.
4.	Деление (/): делит одно число на другое.
5.	Остаток от деления (%): возвращает остаток от деления.
Операции отношений:
1.	== — равно.
2.	!= — не равно.
3.	> — больше.
4.	< — меньше.
5.	>= — больше или равно.
6.	<= — меньше или равно.
Логические операции:
1.	&& — логическое И.
2.	|| — логическое ИЛИ.
3.	! — логическое НЕ.
Преобразования числовых типов:
1.	Неявное преобразование (Widening): автоматическое преобразование меньшего типа в больший (например, int в long).
2.	Явное преобразование (Narrowing): требует указания типа вручную (например, double в int).
________________________________________
8. Символьные строки, методы работы со строками Java.
Символьные строки:
Строки в Java представлены классом String. Они являются неизменяемыми объектами.
Основные методы работы со строками:
1.	length() — возвращает длину строки.
2.	charAt(int index) — возвращает символ по индексу.
3.	substring(int beginIndex, int endIndex) — извлекает подстроку.
4.	toUpperCase() и toLowerCase() — преобразуют строку в верхний или нижний регистр.
5.	trim() — удаляет начальные и конечные пробелы.
6.	replace(CharSequence target, CharSequence replacement) — заменяет часть строки.
7.	split(String regex) — разделяет строку на массив строк по регулярному выражению.
________________________________________
9. Классы StringBuffer и StringBuilder.
StringBuffer:
1.	Используется для создания изменяемых строк.
2.	Потокобезопасен (synchronized).
3.	Менее производителен, чем StringBuilder.
StringBuilder:
1.	Также предназначен для изменяемых строк.
2.	Не потокобезопасен.
3.	Быстрее, чем StringBuffer.
Основные методы обоих классов:
1.	append(String str) — добавляет строку.
2.	insert(int offset, String str) — вставляет строку по указанному индексу.
3.	delete(int start, int end) — удаляет символы.
4.	reverse() — разворачивает строку.
________________________________________
10. Массивы Java: объявление, инициализация. Основные методы класса Arrays. Доступ к элементам массивов, итерация массивов. Двумерные массивы.
Объявление и инициализация массивов:
1.	Одномерные массивы: 
2.	int[] array = new int[5];
3.	int[] array = {1, 2, 3, 4, 5};
4.	Двумерные массивы: 
5.	int[][] matrix = new int[3][3];
6.	int[][] matrix = {{1, 2}, {3, 4}, {5, 6}};
Основные методы класса Arrays:
1.	sort(int[] array) — сортирует массив.
2.	binarySearch(int[] array, int key) — выполняет бинарный поиск.
3.	equals(int[] a, int[] b) — сравнивает массивы.
4.	fill(int[] array, int value) — заполняет массив значением.
Доступ к элементам:
Элементы массива доступны по индексу, начиная с 0:
int value = array[0];
Итерация массивов:
1.	Через цикл for: 
2.	for (int i = 0; i < array.length; i++) {
3.	    System.out.println(array[i]);
4.	}
5.	Через цикл foreach: 
6.	for (int value : array) {
7.	    System.out.println(value);
8.	}
Двумерные массивы:
1.	Доступ к элементу: 
2.	int value = matrix[1][2];
3.	Итерация: 
4.	for (int i = 0; i < matrix.length; i++) {
5.	    for (int j = 0; j < matrix[i].length; j++) {
6.	        System.out.println(matrix[i][j]);
7.	    }
8.	}



11. Управляющие конструкции Java: ветвление, циклы. Цикл foreach.
Управляющие конструкции в Java позволяют организовывать выполнение кода в зависимости от условий или повторять его.
1.	Ветвление:
o	if-else: выполняет блок кода в зависимости от условия. 
o	if (условие) {
o	    // код, если условие истинно
o	} else {
o	    // код, если условие ложно
o	}
o	switch: используется для выбора одного из множества возможных вариантов выполнения. 
o	switch (переменная) {
o	    case значение1:
o	        // код
o	        break;
o	    case значение2:
o	        // код
o	        break;
o	    default:
o	        // код
o	}
2.	Циклы:
o	for: используется для повторения кода фиксированное количество раз. 
o	for (инициализация; условие; итерация) {
o	    // код
o	}
o	while: выполняет блок кода, пока условие истинно. 
o	while (условие) {
o	    // код
o	}
o	do-while: сначала выполняет код, затем проверяет условие. 
o	do {
o	    // код
o	} while (условие);
3.	Цикл foreach:
Используется для перебора элементов коллекции или массива.
4.	for (ТипПеременной элемент : коллекция) {
5.	    // код
6.	}
________________________________________
12. Перечислить и дать описание основных принципов объектно-ориентированного программирования (ООП). Достоинства и недостатки ООП.
1.	Принципы ООП:
o	Абстракция: выделение ключевых характеристик объекта, скрытие деталей реализации.
o	Инкапсуляция: объединение данных и методов, работающих с ними, в единый класс; защита данных от прямого доступа.
o	Наследование: возможность создания новых классов на основе существующих, что обеспечивает повторное использование кода.
o	Полиморфизм: способность объекта вести себя по-разному в зависимости от контекста (например, перегрузка и переопределение методов).
2.	Достоинства ООП:
o	Повышение читаемости и удобства сопровождения кода.
o	Модульность: код можно разделить на отдельные компоненты.
o	Повторное использование кода за счет наследования.
3.	Недостатки ООП:
o	Сложность проектирования.
o	Более высокая потребность в ресурсах для реализации.
o	Неподходящая для задач, которые проще решить в процедурном стиле.
________________________________________
13. Определение класса. Объявление класса. Спецификаторы доступа. Отношения между классами Java (наследование, зависимость, агрегирование). Статические члены класса. Переменные класса.
1.	Класс:
o	Шаблон для создания объектов, описывающий их состояние (переменные) и поведение (методы).
2.	public class MyClass {
3.	    private int поле;
4.	    public void метод() {
5.	        // код
6.	    }
7.	}
8.	Спецификаторы доступа:
o	public: доступен везде.
o	private: доступен только внутри класса.
o	protected: доступен в пакете и подклассах.
o	default: доступен только внутри пакета.
9.	Отношения между классами:
o	Наследование: "is-a" (подкласс является специализированным вариантом суперкласса).
o	Зависимость: "uses" (один класс использует другой).
o	Агрегирование: "has-a" (класс содержит экземпляры других классов).
10.	Статические члены:
o	Привязаны к классу, а не к объекту.
11.	public static int статическаяПеременная;
12.	public static void статическийМетод() {
13.	    // код
14.	}
15.	Переменные класса:
o	Локальные, экземпляра и статические (глобальные).
________________________________________
14. Объект класса. Создание объекта. Конструктор класса, конструктор по умолчанию. Ключевое слово this. Перегрузка конструкторов. Доступ к переменным экземпляра.
1.	Объект:
Экземпляр класса, имеющий состояние и поведение.
2.	MyClass объект = new MyClass();
3.	Конструктор:
Метод, который вызывается при создании объекта.
4.	public MyClass() {
5.	    // код
6.	}
7.	Конструктор по умолчанию:
Создается автоматически, если нет других конструкторов.
8.	Ключевое слово this:
Ссылается на текущий объект.
9.	public MyClass(int поле) {
10.	    this.поле = поле;
11.	}
12.	Перегрузка конструкторов:
Создание нескольких конструкторов с разными параметрами.
13.	public MyClass() {}
14.	public MyClass(int значение) {}
15.	Доступ к переменным экземпляра:
Через методы или напрямую, если доступ разрешен.
________________________________________
15. Методы, объявление, имя. Статические методы. Доступ к методам. Спецификаторы доступа.
1.	Методы:
Определяют поведение класса.
2.	public void имяМетода() {
3.	    // код
4.	}
5.	Статические методы:
Привязаны к классу, вызываются без создания объекта.
6.	public static void статическийМетод() {
7.	    // код
8.	}
9.	Доступ к методам:
Через объект или имя класса (для статических методов).
10.	Спецификаторы доступа:
o	Аналогичны спецификаторам доступа для переменных: public, private, protected, default.


16. Пакеты Java. Импорт пакетов и классов. Статический импорт.
1.	Пакеты Java:
Пакет — это группировка классов и интерфейсов, используемая для организации кода.
o	Пакеты помогают избегать конфликтов имен.
o	Стандартная структура пакетов Java начинается с java и javax.
Пример создания пакета:
package mypackage;
public class MyClass {
    // код
}
2.	Импорт пакетов и классов:
Импорт позволяет использовать классы из другого пакета.
3.	import java.util.Scanner;  // импорт конкретного класса
4.	import java.util.*;       // импорт всех классов пакета
5.	Статический импорт:
Позволяет импортировать статические методы или поля, чтобы вызывать их без указания имени класса.
6.	import static java.lang.Math.*;  // позволяет использовать Math.sqrt() как sqrt()
________________________________________
17. Вложенные и внутренние классы Java. Статические и нестатические внутренние классы.
1.	Вложенные классы:
Классы, объявленные внутри другого класса.
2.	Типы вложенных классов:
o	Статические внутренние классы:
Доступны без создания экземпляра внешнего класса.
o	public class Outer {
o	    static class StaticNested {
o	        // код
o	    }
o	}
o	Нестатические (внутренние) классы:
Имеют доступ к членам внешнего класса.
o	public class Outer {
o	    class Inner {
o	        // код
o	    }
o	}
3.	Локальные классы:
Объявляются внутри метода и видны только в его рамках.
4.	Анонимные классы:
Создаются без имени, часто используются для реализации интерфейсов.
5.	Runnable r = new Runnable() {
6.	    public void run() {
7.	        // код
8.	    }
9.	};
________________________________________
18. Наследование. Подклассы и суперклассы. Доступ к членам класса. Конструкторы при наследовании, ключевое слово super.
1.	Наследование:
Позволяет создавать новый класс на основе существующего (переиспользование кода).
2.	public class SuperClass {
3.	    // код
4.	}
5.	public class SubClass extends SuperClass {
6.	    // код
7.	}
8.	Подклассы и суперклассы:
o	Суперкласс: родительский класс.
o	Подкласс: дочерний класс, наследует члены суперкласса.
9.	Доступ к членам класса:
o	Члены суперкласса доступны в подклассе в зависимости от модификаторов доступа (protected, public).
10.	Конструкторы при наследовании:
o	Конструктор подкласса должен вызывать конструктор суперкласса.
11.	public SubClass() {
12.	    super();  // вызов конструктора суперкласса
13.	}
14.	Ключевое слово super:
Используется для вызова членов суперкласса (конструкторов, методов, полей).
________________________________________
19. Иерархия наследования Java. Преобразование типов при наследовании. Ключевое слово instanceof.
1.	Иерархия наследования:
o	Java поддерживает одноуровневое наследование (один класс может иметь только одного родителя).
o	Все классы наследуются от базового класса Object.
2.	Преобразование типов:
o	Upcasting: преобразование подкласса в суперкласс (без явного указания). 
o	SuperClass obj = new SubClass();
o	Downcasting: преобразование суперкласса в подкласс (требуется явное указание). 
o	SubClass obj = (SubClass) superClassObj;
3.	Ключевое слово instanceof:
Проверяет, является ли объект экземпляром конкретного класса или его подкласса.
4.	if (obj instanceof SubClass) {
5.	    // код
6.	}
________________________________________
20. Полиморфизм в Java. Перегрузка и переопределение методов.
1.	Полиморфизм:
Возможность одного интерфейса предоставлять разные реализации.
2.	Перегрузка методов:
Методы с одинаковым именем, но разными параметрами.
3.	public class MyClass {
4.	    void метод(int a) {}
5.	    void метод(String b) {}
6.	}
7.	Переопределение методов:
Подкласс переопределяет метод суперкласса.
8.	public class SubClass extends SuperClass {
9.	    @Override
10.	    void метод() {
11.	        // новая реализация
12.	    }
13.	}
14.	Виды полиморфизма:
o	Компиляционный: перегрузка методов.
o	Рантайм-полиморфизм: переопределение методов.
________________________________________
21. Абстрактные методы и классы Java.
1.	Абстрактный класс:
Класс, который не может быть создан как объект и может содержать абстрактные методы.
2.	public abstract class AbstractClass {
3.	    abstract void метод();
4.	}
5.	Абстрактные методы:
Методы без реализации; должны быть переопределены в подклассе.
6.	Правила:
o	Абстрактный класс может содержать конкретные методы.
o	Если класс содержит хотя бы один абстрактный метод, он должен быть объявлен как абстрактный.
7.	Пример:
8.	abstract class Shape {
9.	    abstract void draw();
10.	}
11.	class Circle extends Shape {
12.	    void draw() {
13.	        // реализация
14.	    }
15.	}

22. Интерфейсы Java: определение интерфейса, реализация интерфейса. Преимущества применения интерфейсов. Переменные интерфейсов. Наследование интерфейсов. Методы по умолчанию. Статические методы интерфейсов.

Интерфейс в Java — это ссылочный тип, который похож на класс, но может содержать только константы, сигнатуры методов (без их реализации), методы по умолчанию, статические методы и вложенные типы. Интерфейсы используются для определения контракта, который должны реализовывать классы.
Определение интерфейса
Интерфейс определяется с помощью ключевого слова interface
Реализация интерфейса
Класс может реализовать интерфейс с помощью ключевого слова implements. Класс, реализующий интерфейс, должен предоставить реализацию всех абстрактных методов интерфейса (если только он сам не является абстрактным классом).
class MyClass implements MyInterface {
    @Override
    public void myMethod() {
        System.out.println("Implemented method");
    }
}
Преимущества применения интерфейсов
1.	Абстракция: Интерфейсы позволяют скрыть детали реализации и сосредоточиться на том, что должен делать объект, а не на том, как он это делает.
2.	Множественное наследование: В Java класс может реализовывать несколько интерфейсов, что позволяет достичь подобия множественного наследования.
3.	Гибкость: Интерфейсы позволяют легко изменять реализацию, не изменяя код, который зависит от интерфейса.
4.	Слабосвязанность: Классы, зависящие от интерфейсов, а не от конкретных реализаций, легче тестировать и поддерживать.
Переменные интерфейсов
Переменные, объявленные в интерфейсе, по умолчанию являются public, static и final. Это означает, что они являются константами и не могут быть изменены.
Наследование интерфейсов
Интерфейсы могут наследовать другие интерфейсы с помощью ключевого слова extends. Это позволяет создавать иерархии интерфейсов.
Методы по умолчанию
Методы по умолчанию (default methods) позволяют добавлять новые методы в интерфейсы без нарушения существующих реализаций. Они имеют реализацию по умолчанию, которая может быть переопределена в классах.
Статические методы интерфейсов
Статические методы в интерфейсах похожи на статические методы в классах. Они принадлежат интерфейсу, а не экземпляру класса, и могут быть вызваны без создания объекта.

 23. Исключения (exception) Java. Синтаксис объявления исключений. Классификация исключений. Основные классы для работы с исключениями. Исключения при наследовании. 

Исключения в Java — это события, которые возникают во время выполнения программы и нарушают нормальный ход её выполнения. Они используются для обработки ошибок и других неожиданных ситуаций.
Синтаксис объявления исключений
Исключения в Java объявляются с помощью ключевого слова throw. Пример:
java
Copy
throw new Exception("Сообщение об ошибке");
Для обработки исключений используется конструкция try-catch-finally
Классификация исключений
Исключения в Java делятся на три основные категории:
1.	Проверяемые исключения (Checked Exceptions):
o	Это исключения, которые проверяются на этапе компиляции.
o	Пример: IOException, SQLException.
o	Должны быть либо обработаны с помощью try-catch, либо объявлены в сигнатуре метода с помощью throws.
2.	Непроверяемые исключения (Unchecked Exceptions):
o	Это исключения, которые не проверяются на этапе компиляции.
o	Пример: NullPointerException, ArithmeticException.
o	Обычно возникают из-за ошибок в логике программы.
3.	Ошибки (Errors):
o	Это серьезные проблемы, которые приложение не должно пытаться обрабатывать.
o	Пример: OutOfMemoryError, StackOverflowError.
o	Обычно возникают из-за проблем в JVM.
Основные классы для работы с исключениями
•	Throwable: Базовый класс для всех исключений и ошибок.
o	Exception: Базовый класс для всех проверяемых и непроверяемых исключений.
	RuntimeException: Базовый класс для всех непроверяемых исключений.
o	Error: Базовый класс для всех ошибок.
Исключения при наследовании
При наследовании в Java есть несколько важных правил, связанных с исключениями:
1.	Переопределение методов:
o	Если метод в суперклассе не выбрасывает исключений, то переопределяющий метод в подклассе не может выбрасывать проверяемые исключения.
o	Если метод в суперклассе выбрасывает проверяемые исключения, то переопределяющий метод в подклассе может:
2.	Конструкторы:
o	Конструкторы подкласса могут выбрасывать исключения, даже если конструкторы суперкласса не выбрасывают исключений.
o	Однако, если конструктор суперкласса выбрасывает проверяемые исключения, конструктор подкласса должен либо обработать их, либо объявить в своей сигнатуре.



24. Коллекции: Java collections framework. Классификация интерфейсов коллекций. Интерфейс Collection.

Java Collections Framework (JCF) — это набор интерфейсов, классов и алгоритмов, которые предоставляют стандартные способы работы с коллекциями объектов. Коллекции используются для хранения, обработки и управления группами объектов.
Классификация интерфейсов коллекций
Интерфейсы коллекций в Java можно разделить на несколько категорий:
1.	Основные интерфейсы:
o	Collection: Базовый интерфейс для всех коллекций.
o	List: Упорядоченная коллекция, которая может содержать дубликаты.
o	Set: Коллекция, которая не содержит дубликатов.
o	Queue: Коллекция, предназначенная для хранения элементов в порядке, который используется для обработки (например, FIFO).
o	Deque: Двусторонняя очередь, которая поддерживает добавление и удаление элементов с обоих концов.
2.	Интерфейсы для работы с отображениями (Map):
o	Map: Коллекция, которая хранит пары ключ-значение. Ключи уникальны.
3.	Интерфейсы для работы с отсортированными коллекциями:
o	SortedSet: Упорядоченный набор, который не содержит дубликатов.
o	SortedMap: Упорядоченное отображение, которое хранит пары ключ-значение, отсортированные по ключам
Интерфейс Collection является корневым интерфейсом для всех коллекций в Java. Он определяет основные методы для работы с коллекциями:
•	Добавление элементов:
o	boolean add(E e): Добавляет элемент в коллекцию.
o	boolean addAll(Collection<? extends E> c): Добавляет все элементы из указанной коллекции.
•	Удаление элементов:
o	boolean remove(Object o): Удаляет указанный элемент из коллекции.
o	boolean removeAll(Collection<?> c): Удаляет все элементы, которые содержатся в указанной коллекции.
o	void clear(): Удаляет все элементы из коллекции.
•	Проверка наличия элементов:
o	boolean contains(Object o): Проверяет, содержит ли коллекция указанный элемент.
o	boolean containsAll(Collection<?> c): Проверяет, содержит ли коллекция все элементы из указанной коллекции.
•	Размер коллекции:
o	int size(): Возвращает количество элементов в коллекции.
o	boolean isEmpty(): Проверяет, пуста ли коллекция.
•	Итерация по элементам:
o	Iterator<E> iterator(): Возвращает итератор для обхода элементов коллекции.
•	Преобразование в массив:
o	Object[] toArray(): Возвращает массив, содержащий все элементы коллекции.
o	<T> T[] toArray(T[] a): Возвращает массив, содержащий все элементы коллекции, с указанным типом.


 25. Списки. Интерфейс List. Основные классы, реализующие интерфейс List. ArrayList, особенности, методы. Comparator. 
В Java интерфейс List является частью коллекций (Collections Framework) и представляет собой упорядоченную коллекцию элементов, которые могут содержать дубликаты. Элементы в списке доступны по индексу, начиная с 0.
Основные классы, реализующие интерфейс List
1.	ArrayList:
•	Динамический массив, который автоматически увеличивает свой размер при добавлении элементов.
•	Быстрый доступ по индексу, но медленное добавление и удаление элементов в середине списка.
2.	LinkedList:
•	Реализация списка на основе двусвязного списка.
•	Быстрое добавление и удаление элементов в начале и конце списка, но медленный доступ по индексу.
3.	Vector:
•	Устаревший класс, похожий на ArrayList, но с синхронизированными методами.
•	Медленнее ArrayList из-за синхронизации.
4.	Stack:
•	Подкласс Vector, реализующий структуру данных "стек" (LIFO).
ArrayList: особенности и методы
ArrayList — это наиболее часто используемая реализация интерфейса List. Основные особенности:
•	Динамический размер: ArrayList автоматически увеличивает свой размер при добавлении элементов.
•	Быстрый доступ по индексу: Время доступа к элементу по индексу — O(1).
•	Медленное добавление/удаление в середине: Время добавления или удаления элемента в середине списка — O(n), так как требуется сдвиг элементов.
Основные методы ArrayList:
•	add(E e): Добавляет элемент в конец списка.
•	add(int index, E element): Вставляет элемент на указанную позицию.
•	get(int index): Возвращает элемент по указанному индексу.
•	set(int index, E element): Заменяет элемент на указанной позиции.
•	remove(int index): Удаляет элемент по указанному индексу.
•	remove(Object o): Удаляет первое вхождение указанного элемента.
•	size(): Возвращает количество элементов в списке.
•	clear(): Удаляет все элементы из списка.
•	contains(Object o): Проверяет, содержится ли элемент в списке.
•	indexOf(Object o): Возвращает индекс первого вхождения элемента.
•	isEmpty(): Проверяет, пуст ли список.
Comparator — это функциональный интерфейс, который используется для сравнения двух объектов. Он позволяет сортировать коллекции по заданному критерию.
Основной метод интерфейса Comparator:
•	compare(T o1, T o2): Сравнивает два объекта


26. Интерфейс Set. Основные реализации. HashSet. TreeSet. 
Интерфейс Set в Java представляет собой коллекцию, которая не допускает дубликатов. Это означает, что каждый элемент в Set может встречаться только один раз. Set не гарантирует порядок элементов, за исключением некоторых его реализаций.
Основные реализации интерфейса Set
1.	HashSet:
•	Основан на хеш-таблице.
•	Не гарантирует порядок элементов.
•	Быстрые операции добавления, удаления и проверки на наличие элемента (в среднем O(1)).
•	Не допускает дубликатов.
2.	LinkedHashSet:
•	Подкласс HashSet, который сохраняет порядок добавления элементов.
•	Использует связный список для хранения элементов в порядке их вставки.
•	Быстрые операции, как и у HashSet, с дополнительным преимуществом сохранения порядка.
3.	TreeSet:
•	Реализует интерфейс NavigableSet и основан на красно-черном дереве.
•	Гарантирует сортировку элементов в естественном порядке или по заданному компаратору.
•	Операции добавления, удаления и поиска имеют сложность O(log n).
•	Не допускает дубликатов.
HashSet: особенности и методы
HashSet — это наиболее часто используемая реализация интерфейса Set. Основные особенности:
•	Неупорядоченность: Элементы не имеют фиксированного порядка.
•	Быстродействие: Операции добавления, удаления и проверки на наличие элемента выполняются быстро.
•	Не допускает дубликатов: Если вы попытаетесь добавить дубликат, HashSet просто проигнорирует его.
Основные методы HashSet:
•	add(E e): Добавляет элемент в множество.
•	remove(Object o): Удаляет элемент из множества.
•	contains(Object o): Проверяет, содержится ли элемент в множестве.
•	size(): Возвращает количество элементов в множестве.
•	isEmpty(): Проверяет, пусто ли множество.
•	clear(): Удаляет все элементы из множества.
•	iterator(): Возвращает итератор для перебора элементов.
TreeSet: особенности и методы
TreeSet — это реализация Set, которая хранит элементы в отсортированном порядке. Основные особенности:
•	Сортировка: Элементы хранятся в отсортированном порядке, что позволяет выполнять операции поиска и навигации.
•	Сложность операций: Операции добавления, удаления и поиска имеют сложность O(log n).
•	Не допускает дубликатов: Как и все реализации Set, TreeSet не допускает дубликатов.
Основные методы TreeSet:
•	add(E e): Добавляет элемент в множество.
•	remove(Object o): Удаляет элемент из множества.
•	contains(Object o): Проверяет, содержится ли элемент в множестве.
•	first(): Возвращает первый (наименьший) элемент.
•	last(): Возвращает последний (наибольший) элемент.
•	lower(E e): Возвращает наибольший элемент, меньший указанного.
•	higher(E e): Возвращает наименьший элемент, больший указанного.
•	size(): Возвращает количество элементов в множестве.
•	isEmpty(): Проверяет, пусто ли множество.
•	clear(): Удаляет все элементы из множества.

27. Очереди в Java, интерфейс Queue, PrioritiQueue. Структура, основные методы.
Очередь (Queue) в Java — это структура данных, которая следует принципу FIFO (First In, First Out), что означает, что элементы добавляются в конец очереди и извлекаются из начала. Очереди часто используются в сценариях, где необходимо обрабатывать элементы в порядке их поступления.
Интерфейс Queue
Интерфейс Queue является частью Java Collections Framework и расширяет интерфейс Collection. Он определяет методы для работы с очередями.
Основные реализации интерфейса Queue
1.	LinkedList: Реализует интерфейс Queue и может использоваться как очередь. Поддерживает все операции, включая добавление, удаление и доступ к элементам.
2.	ArrayDeque: Реализация очереди на основе динамического массива. Поддерживает операции добавления и удаления элементов с обеих сторон (как очередь, так и стек).
3.	PriorityQueue: Реализация очереди, которая сортирует элементы на основе их естественного порядка или заданного компаратора. Элементы с более высоким приоритетом извлекаются первыми.
PriorityQueue: структура и основные методы
PriorityQueue — это реализация интерфейса Queue, которая организует элементы в порядке их приоритета. Элементы с более высоким приоритетом будут извлекаться первыми, независимо от порядка их добавления.
Основные особенности PriorityQueue:
•	Не гарантирует порядок: Хотя элементы извлекаются в порядке приоритета, порядок добавления не сохраняется.
•	Использует хип: Внутренне PriorityQueue реализован с использованием структуры данных "куча" (heap), что обеспечивает эффективное извлечение элементов с высоким приоритетом.
•	Не допускает null: PriorityQueue не может содержать null элементы.
Основные методы PriorityQueue:
•	add(E e): Добавляет элемент в очередь.
•	offer(E e): Добавляет элемент в очередь (аналогично add, но возвращает false, если не удалось добавить).
•	remove(): Удаляет и возвращает элемент с наивысшим приоритетом. Если очередь пуста, выбрасывает NoSuchElementException.
•	poll(): Удаляет и возвращает элемент с наивысшим приоритетом или возвращает null, если очередь пуста.
•	peek(): Возвращает элемент с наивысшим приоритетом, не удаляя его, или возвращает null, если очередь пуста.
•	size(): Возвращает количество элементов в очереди.
•	isEmpty(): Проверяет, пуста ли очередь.

 
28. Байтовые потоки InputStream и OutputStream. Консольный ввод и вывод Java. Символьные потоки данных. Абстрактные классы Writer, Reader. 
Байтовые потоки: InputStream и OutputStream
В Java байтовые потоки используются для работы с бинарными данными. Они позволяют читать и записывать данные в виде последовательности байтов. Основные абстрактные классы для работы с байтовыми потоками:
•	InputStream: Абстрактный класс, представляющий входной поток байтов. Он предоставляет методы для чтения данных.
•	OutputStream: Абстрактный класс, представляющий выходной поток байтов. Он предоставляет методы для записи данных.
Основные методы InputStream:
•	int read(): Читает следующий байт данных из входного потока и возвращает его в виде целого числа (от 0 до 255). Если конец потока достигнут, возвращает -1.
•	int read(byte[] b): Читает несколько байтов данных из входного потока и записывает их в массив байтов b. Возвращает количество прочитанных байтов или -1, если конец потока достигнут.
•	void close(): Закрывает поток и освобождает связанные с ним ресурсы.
Основные методы OutputStream:
•	void write(int b): Записывает указанный байт в выходной поток.
•	void write(byte[] b): Записывает массив байтов в выходной поток.
•	void close(): Закрывает поток и освобождает связанные с ним ресурсы.
Консольный ввод и вывод в Java
Для работы с консольным вводом и выводом в Java часто используются классы System.in и System.out.
•	System.in: Это стандартный входной поток, который обычно связан с клавиатурой. Он является экземпляром InputStream.
•	System.out: Это стандартный выходной поток, который обычно связан с консолью. Он является экземпляром OutputStream.
Символьные потоки данных
Символьные потоки используются для работы с текстовыми данными. Они позволяют читать и записывать данные в виде символов, а не байтов. Основные абстрактные классы для работы с символьными потоками:
•	Reader: Абстрактный класс, представляющий входной символьный поток. Он предоставляет методы для чтения символов.
•	Writer: Абстрактный класс, представляющий выходной символьный поток. Он предоставляет методы для записи символов.
Основные методы Reader:
•	int read(): Читает следующий символ из входного потока и возвращает его в виде целого числа. Если конец потока достигнут, возвращает -1.
•	int read(char[] cbuf): Читает несколько символов из входного потока и записывает их в массив символов cbuf. Возвращает количество прочитанных символов или -1, если конец потока достигнут.
•	void close(): Закрывает поток и освобождает связанные с ним ресурсы.
Основные методы Writer:
•	void write(int c): Записывает указанный символ в выходной поток.
•	void write(char[] cbuf): Записывает массив символов в выходной поток.
•	void close(): Закрывает поток и освобождает связанные с ним ресурсы.

29. Чтение и запись файлов. Классы FileInputStream, FileOutputStream. Файловый вводвывод с использованием символьных потоков. Классы FileReader и FileWriter. 
В Java для работы с файлами используются различные классы, которые позволяют читать и записывать данные. Основные классы для работы с байтовыми потоками — это FileInputStream и FileOutputStream, а для символьных потоков — FileReader и FileWriter.
Чтение и запись с использованием байтовых потоков
Класс FileInputStream
FileInputStream используется для чтения байтов из файла. Он позволяет считывать данные в виде байтов, что полезно для работы с бинарными файлами.
Класс FileOutputStream
FileOutputStream используется для записи байтов в файл. Он позволяет записывать данные в виде байтов, что также полезно для работы с бинарными файлами.
Класс FileReader
FileReader используется для чтения символов из файла. Он позволяет считывать текстовые данные, что делает его подходящим для работы с текстовыми файлами.
Класс FileWriter
FileWriter используется для записи символов в файл. Он позволяет записывать текстовые данные в файл.

30. Многопоточное программирование: общие принципы.
Многопоточное программирование: общие принципы
Многопоточное программирование — это парадигма, позволяющая выполнять несколько потоков (или процессов) одновременно, что может значительно повысить производительность и отзывчивость приложений. В Java многопоточность реализуется с помощью классов и интерфейсов, предоставляемых Java Concurrency API. Ниже приведены основные принципы и концепции, связанные с многопоточным программированием.
1. Поток (Thread)
•	Определение: Поток — это наименьшая единица выполнения в программе. Каждый поток имеет свою собственную стековую память и может выполняться параллельно с другими потоками.
•	Создание потоков: В Java потоки можно создавать несколькими способами:
•	Наследование от класса Thread: Создайте подкласс Thread и переопределите метод run().
•	Реализация интерфейса Runnable: Создайте класс, реализующий интерфейс Runnable, и передайте его в объект Thread.
2. Синхронизация
•	Проблема состояния гонки: Когда несколько потоков обращаются к общим ресурсам (например, переменным или объектам), может возникнуть состояние гонки, когда результаты зависят от порядка выполнения потоков.
•	Синхронизация: Для предотвращения состояния гонки используются механизмы синхронизации:
•	Синхронизированные методы: Используйте ключевое слово synchronized для методов, чтобы гарантировать, что только один поток может выполнять метод в одно и то же время.
•	Синхронизированные блоки: Используйте синхронизированные блоки для более точного контроля над тем, какие части кода должны быть защищены от одновременного доступа.
3. Пул потоков
•	Определение: Пул потоков — это коллекция потоков, которые могут быть повторно использованы для выполнения задач. Это позволяет избежать накладных расходов на создание и уничтожение потоков.
•	Использование: Java предоставляет ExecutorService для управления пулами потоков, что упрощает выполнение асинхронных задач.
4. Параллелизм и конкуренция
•	Параллелизм: Это выполнение нескольких операций одновременно, что может быть достигнуто с помощью многопоточности.
•	Конкуренция: Это ситуация, когда несколько потоков пытаются получить доступ к общим ресурсам, что может привести к состояниям гонки и другим проблемам.


 31. Класс Тhread и интерфейс Runnable: создание потоков, приоритеты потоков. 
В Java многопоточность может быть реализована с помощью класса Thread и интерфейса Runnable. Оба подхода позволяют создавать и управлять потоками, но имеют свои особенности и преимущества.
1. Класс Thread
Класс Thread представляет собой поток выполнения. Вы можете создать новый поток, создав экземпляр класса Thread и переопределив его метод run(), который содержит код, выполняемый в этом потоке.
2. Интерфейс Runnable
Интерфейс Runnable представляет собой функциональный интерфейс, который содержит единственный метод run(). Этот подход более гибкий, так как позволяет разделять логику потока от его реализации. Вы можете реализовать интерфейс Runnable в любом классе и передать его в объект Thread
Приоритеты потоков
В Java каждый поток имеет приоритет, который определяет, как часто он будет получать доступ к процессорному времени по сравнению с другими потоками. Приоритеты потоков могут быть установлены с помощью методов setPriority(int priority) и getPriority().
Уровни приоритетов
Приоритеты потоков в Java могут принимать значения от Thread.MIN_PRIORITY (1) до Thread.MAX_PRIORITY (10), с Thread.NORM_PRIORITY (5) как значением по умолчанию.

32. Приостановка и прерывание потоков. Определение момента завершения потока. 
В Java управление потоками включает в себя возможность приостановки, возобновления и завершения потоков. Однако важно отметить, что некоторые методы, такие как stop() и suspend(), устарели и не рекомендуются к использованию из-за проблем с безопасностью и целостностью данных. Вместо этого рекомендуется использовать более безопасные подходы для управления потоками.
1. Приостановка потоков
Для приостановки потока можно использовать флаг состояния, который будет проверяться в цикле выполнения потока. Это позволяет безопасно приостанавливать и возобновлять поток.
2. Прерывание потоков
Прерывание потока — это способ уведомить поток о том, что он должен завершить свою работу. Для этого используется метод interrupt(), который устанавливает флаг прерывания для потока. Поток может проверять этот флаг и завершать свою работу, если он установлен.
Определение момента завершения потока
Чтобы определить, завершился ли поток, можно использовать метод isAlive(), который возвращает true, если поток еще выполняется, и false, если он завершил свою работу.

33. Синхронизация потоков.
Синхронизация потоков — это механизм, который позволяет контролировать доступ к общим ресурсам в многопоточных приложениях. Когда несколько потоков пытаются одновременно получить доступ к общим данным, может возникнуть состояние гонки, что может привести к непредсказуемым результатам. Синхронизация помогает избежать таких проблем, обеспечивая, что только один поток может получить доступ к ресурсу в определенный момент времени.
Основные концепции синхронизации
1.	Синхронизированные методы:
•	Вы можете объявить метод как синхронизированный, добавив ключевое слово synchronized перед его объявлением. Это гарантирует, что только один поток может выполнять этот метод для данного объекта в одно и то же время.
Синхронизированные блоки:
•	Синхронизированные блоки позволяют более точно контролировать, какие части кода должны быть защищены от одновременного доступа. Это может быть полезно для повышения производительности, так как позволяет избежать блокировки всего метода.
Синхронизация на уровне класса:
•	Вы можете синхронизировать методы или блоки кода на уровне класса, используя ключевое слово synchronized с классом в качестве объекта блокировки. Это гарантирует, что только один поток может выполнять синхронизированный метод для всех экземпляров класса.
Использование ReentrantLock
Java также предоставляет более гибкие механизмы синхронизации через класс ReentrantLock, который позволяет более детально управлять блокировками.

 34. Архитектура JDBC (Java DataBase Connectivity). Двух и трехуровневые модели доступа к базе данных. Преимущества и недостатки JDBC. 
Архитектура JDBC (Java DataBase Connectivity)
JDBC (Java DataBase Connectivity) — это API, который позволяет Java-приложениям взаимодействовать с базами данных. Основные компоненты JDBC:
1.	JDBC Driver: Компонент, реализующий интерфейсы JDBC для конкретной базы данных. Существует несколько типов драйверов:
•	Тип 1: JDBC-ODBC Bridge Driver.
•	Тип 2: Native-API Driver.
•	Тип 3: Network Protocol Driver.
•	Тип 4: Thin Driver (чисто Java-драйвер).
2.	JDBC API: Набор интерфейсов и классов для выполнения SQL-запросов и управления транзакциями. Основные интерфейсы:
•	DriverManager
•	Connection
•	Statement
•	PreparedStatement
•	ResultSet
3.	JDBC Application: Java-приложение, использующее JDBC API для работы с базой данных.
Двухуровневая и трехуровневая модели доступа к базе данных
Двухуровневая модель
•	Описание: Клиентское приложение напрямую взаимодействует с базой данных через JDBC.
•	Преимущества: Простота реализации, низкая задержка.
•	Недостатки: Ограниченная масштабируемость, проблемы с безопасностью.
Трехуровневая модель
•	Описание: Клиентское приложение взаимодействует с сервером приложений, который затем взаимодействует с базой данных.
•	Преимущества: Улучшенная безопасность, лучшая масштабируемость, упрощение управления транзакциями.
•	Недостатки: Более сложная архитектура, увеличение задержки.
Преимущества и недостатки JDBC
Преимущества
1.	Портативность: Работает на любой платформе, поддерживающей Java.
2.	Стандартный интерфейс: Упрощает разработку и поддержку приложений.
3.	Поддержка различных баз данных: Множество драйверов для разных СУБД.
4.	Гибкость: Позволяет выполнять простые и сложные SQL-запросы.
Недостатки
1.	Сложность управления ресурсами: Необходимость самостоятельно управлять соединениями и запросами.
2.	Отсутствие абстракции: Низкоуровневый доступ может усложнить разработку.
3.	Проблемы с производительностью: Неправильное использование может привести к утечкам ресурсов и снижению производительности.

35. Библиотека Swing, общие черты и особенности. 
Swing — это библиотека графического пользовательского интерфейса (GUI) для Java, которая является частью Java Foundation Classes (JFC). Она предоставляет набор компонентов для создания кроссплатформенных настольных приложений с графическим интерфейсом.
Общие черты Swing
1.	Кроссплатформенность: Swing работает на всех платформах, поддерживающих Java, что позволяет создавать приложения, которые выглядят и ведут себя одинаково на разных операционных системах.
2.	Модель "потокобезопасности": Swing использует модель "один поток" для обработки событий, что упрощает разработку многопоточных приложений. Все изменения в GUI должны выполняться в потоке обработки событий (Event Dispatch Thread).
3.	Компоненты: Swing предоставляет широкий набор компонентов, таких как кнопки, текстовые поля, метки, таблицы, списки и панели, которые можно комбинировать для создания сложных интерфейсов.
4.	Переопределяемый внешний вид: Swing поддерживает "пластины" (Look and Feel), что позволяет изменять внешний вид компонентов без изменения их функциональности. Это позволяет разработчикам создавать интерфейсы, соответствующие стилю операционной системы или пользовательским предпочтениям.
5.	Поддержка MVC: Swing следует архитектурной модели Model-View-Controller (MVC), что позволяет разделять логику приложения, представление и управление данными.
Особенности Swing
1.	Легковесные компоненты: В отличие от AWT (Abstract Window Toolkit), Swing использует легковесные компоненты, которые не зависят от платформы. Это позволяет создавать более гибкие и настраиваемые интерфейсы.
2.	Поддержка событий: Swing предоставляет мощную модель обработки событий, позволяя разработчикам легко реагировать на действия пользователя, такие как нажатия кнопок, выбор элементов и ввод данных.
3.	Расширяемость: Swing позволяет разработчикам создавать собственные компоненты и расширять существующие, что делает библиотеку очень гибкой.
4.	Поддержка графики: Swing включает в себя возможности для работы с графикой, такие как рисование фигур, изображений и текста, что позволяет создавать более сложные и визуально привлекательные интерфейсы.
5.	Интеграция с другими библиотеками: Swing может быть интегрирован с другими библиотеками Java, такими как Java 2D для более сложной графики и JavaFX для создания современных интерфейсов.

36. Виды контейнеров в Swing. 
Виды контейнеров в Swing
В Swing контейнеры используются для организации и управления компонентами пользовательского интерфейса. Они могут содержать другие компоненты и контейнеры, создавая иерархию интерфейса. Основные виды контейнеров в Swing:
1.	JFrame:
•	Основной контейнер для создания оконных приложений.
•	Представляет главное окно приложения и может содержать другие компоненты, такие как панели, кнопки и текстовые поля.
2.	JPanel:
•	Универсальный контейнер, который может содержать другие компоненты и использоваться для группировки элементов.
•	Часто используется для организации интерфейса и управления компоновкой.
3.	JApplet:
•	Контейнер для создания апплетов, которые могут быть встроены в веб-страницы.
•	Подобен JFrame, но предназначен для работы в среде браузера.
4.	JDialog:
•	Контейнер для создания диалоговых окон, которые могут быть модальными или немодальными.
•	Используется для отображения сообщений или получения ввода от пользователя.
5.	JScrollPane:
•	Контейнер, который добавляет возможность прокрутки к другим компонентам, таким как панели или текстовые области.
•	Позволяет пользователю прокручивать содержимое, если оно превышает размеры видимой области.
6.	JSplitPane:
•	Контейнер, который разделяет область на две части, позволяя пользователю изменять размеры этих частей.
•	Полезен для создания интерфейсов с несколькими панелями, которые можно настраивать.
7.	JTabbedPane:
•	Контейнер, который позволяет организовать компоненты в виде вкладок.
•	Удобен для группировки связанных компонентов и упрощения навигации.
8.	JToolBar:
•	Контейнер для размещения панелей инструментов, содержащих кнопки и другие элементы управления.
•	Используется для быстрого доступа к часто используемым функциям приложения

37. Элементы пользовательского интерфейса Swing. 
Элементы пользовательского интерфейса Swing
Swing предоставляет широкий набор компонентов для создания графических пользовательских интерфейсов (GUI). Вот основные элементы пользовательского интерфейса Swing:
1.	JButton:
•	Кнопка, на которую пользователь может нажимать для выполнения действия.
2.	JLabel:
•	Метка для отображения текста или изображения. Не является интерактивным элементом.
3.	JTextField:
•	Однострочное текстовое поле для ввода данных пользователем.
4.	JTextArea:
•	Многострочное текстовое поле для ввода и отображения текста. Поддерживает прокрутку.
5.	JCheckBox:
•	Флажок, который позволяет пользователю выбирать или отменять выбор. Может быть выбран или не выбран.
6.	JRadioButton:
•	Радиокнопка, которая позволяет пользователю выбрать один вариант из группы. В группе может быть только один выбранный элемент.
7.	JComboBox:
•	Выпадающий список, который позволяет пользователю выбирать один элемент из списка. Может поддерживать ввод пользовательского текста.
8.	JList:
•	Список, который позволяет пользователю выбирать один или несколько элементов из набора.
9.	JMenuBar:
•	Панель меню, которая содержит меню (JMenu) для организации команд и опций приложения.
10.	JToolBar:
•	Панель инструментов, содержащая кнопки и другие элементы управления для быстрого доступа к функциям приложения.
11.	JProgressBar:
•	Индикатор прогресса, который отображает состояние выполнения задачи.
12.	JSlider:
•	Ползунок, который позволяет пользователю выбирать значение из заданного диапазона.
13.	JSpinner:
•	Компонент, который позволяет пользователю выбирать значение из заданного диапазона, используя стрелки для увеличения или уменьшения значения.
14.	JTabbedPane:
•	Компонент, который позволяет организовать интерфейс в виде вкладок, каждая из которых может содержать разные панели.

38. Модель событий Swing. Интерфейс EventListener. 
Модель событий Swing
Модель событий в Swing основана на концепции обработки событий, которая позволяет компонентам GUI реагировать на действия пользователя, такие как нажатия кнопок, перемещения мыши и ввод данных. Основные компоненты модели событий Swing:
1.	События (Event):
•	События представляют собой уведомления о том, что произошло какое-то действие (например, нажатие кнопки). В Swing события реализуются через классы, такие как ActionEvent, MouseEvent, KeyEvent и другие.
2.	Источники событий (Event Source):
•	Компоненты, которые генерируют события. Например, кнопка (JButton) является источником события ActionEvent, когда на нее нажимают.
3.	Слушатели событий (Event Listener):
•	Интерфейсы, которые определяют методы для обработки определенных типов событий. Компоненты могут регистрировать слушателей, чтобы получать уведомления о событиях.
Интерфейс EventListener
EventListener — это маркерный интерфейс, который не содержит методов, но служит базовым интерфейсом для всех слушателей событий в Java. Он используется для обозначения классов, которые могут обрабатывать события.
Основные интерфейсы слушателей событий в Swing:
1.	ActionListener:
•	Обрабатывает события действия, такие как нажатия кнопок.
•	Метод: void actionPerformed(ActionEvent e).
2.	MouseListener:
•	Обрабатывает события мыши, такие как нажатия, отпускания и перемещения.
•	Методы: void mouseClicked(MouseEvent e), void mousePressed(MouseEvent e), void mouseReleased(MouseEvent e), void mouseEntered(MouseEvent e), void mouseExited(MouseEvent e).
3.	KeyListener:
•	Обрабатывает события клавиатуры, такие как нажатия и отпускания клавиш.
•	Методы: void keyPressed(KeyEvent e), void keyReleased(KeyEvent e), void keyTyped(KeyEvent e).
4.	ChangeListener:
•	Обрабатывает изменения в компонентах, таких как JSlider или JSpinner.
•	Метод: void stateChanged(ChangeEvent e).

39. Менеджеры компоновки Swing. 
Менеджеры компоновки в Swing отвечают за организацию и размещение компонентов пользовательского интерфейса в контейнерах. Они определяют, как компоненты будут отображаться и изменять свои размеры в зависимости от размеров окна и других компонентов. Вот основные менеджеры компоновки Swing:
1.	FlowLayout:
•	Размещает компоненты в строках, начиная с левого края и переходя к следующей строке, когда не хватает места.
•	Компоненты располагаются в порядке их добавления.
2.	BorderLayout:
•	Разделяет контейнер на пять областей: North, South, East, West и Center.
•	Каждый компонент занимает всю доступную область в своей позиции, и только один компонент может занимать каждую область.
3.	GridLayout:
•	Размещает компоненты в виде сетки с фиксированным количеством строк и столбцов.
•	Все ячейки имеют одинаковый размер, и компоненты заполняют сетку по порядку.
4.	BoxLayout:
•	Размещает компоненты в одном направлении (по вертикали или горизонтали).
•	Позволяет легко управлять выравниванием и пространством между компонентами.
5.	GridBagLayout:
•	Более сложный и гибкий менеджер компоновки, который позволяет размещать компоненты в сетке с возможностью объединения ячеек.
•	Позволяет задавать разные размеры для ячеек и управлять их выравниванием.
6.	CardLayout:
•	Позволяет переключаться между различными панелями (картами) в одном контейнере.
•	Полезен для создания интерфейсов с вкладками или пошаговыми формами.

40. GUI Designer Swing
GUI Designer Swing — это инструмент, который позволяет разработчикам визуально проектировать графические пользовательские интерфейсы (GUI) для Java-приложений с использованием библиотеки Swing. Он упрощает процесс создания интерфейсов, позволяя пользователям перетаскивать компоненты на форму и настраивать их свойства без необходимости писать код вручную.
Основные особенности GUI Designer Swing:
1.	Визуальное проектирование:
•	Позволяет разработчикам видеть, как будет выглядеть интерфейс в реальном времени, что упрощает процесс проектирования.
2.	Перетаскивание компонентов:
•	Компоненты Swing, такие как кнопки, текстовые поля, метки и панели, могут быть добавлены на форму простым перетаскиванием.
3.	Настройка свойств:
•	Свойства компонентов (например, текст, цвет, размер) могут быть изменены через графический интерфейс, что упрощает настройку.
4.	Генерация кода:
•	После завершения проектирования GUI, инструмент может автоматически генерировать соответствующий Java-код, который можно использовать в приложении.
5.	Поддержка менеджеров компоновки:
•	GUI Designer позволяет использовать различные менеджеры компоновки для организации компонентов, что помогает создавать адаптивные интерфейсы.
6.	Интеграция с IDE:
•	Многие IDE, такие как NetBeans и IntelliJ IDEA, имеют встроенные GUI Designer, что позволяет разработчикам легко интегрировать визуальное проектирование в процесс разработки.

41. Текстовые поля в Swing 
Текстовые поля в Swing используются для ввода и отображения текстовой информации пользователем. Основные компоненты для работы с текстом в Swing:
JTextField:
•	Однострочное текстовое поле, позволяющее пользователю вводить текст.
•	Поддерживает различные методы для получения и установки текста, а также для обработки событий, таких как нажатие клавиш.
JTextArea:
•	Многострочное текстовое поле, позволяющее вводить и отображать большие объемы текста.
•	Поддерживает прокрутку, что позволяет работать с текстом, превышающим размеры видимой области.
JPasswordField:
•	Специальный тип текстового поля, предназначенный для ввода паролей. Символы, вводимые в это поле, отображаются в виде звездочек или других символов.

42. Компонент управления JButton в Swing
JButton — это компонент управления в Swing, который представляет собой кнопку, на которую пользователь может нажимать для выполнения определенного действия. Кнопки являются важными элементами пользовательского интерфейса, позволяя инициировать события и взаимодействовать с приложением.
Основные характеристики JButton:
Создание кнопки:
•	Кнопка может быть создана с текстом, иконкой или их комбинацией.
Обработка событий:
•	Для обработки нажатий на кнопку используется интерфейс ActionListener. Разработчик может зарегистрировать слушателя, который будет реагировать на событие нажатия
Состояния кнопки:

JButton может находиться в различных состояниях, таких как обычное, наведенное, нажатое и отключенное. Эти состояния можно настраивать с помощью различных методов.
Иконки:

JButton может отображать иконки, что позволяет создавать более визуально привлекательные интерфейсы.
Стилизация:
JButton можно стилизовать с помощью различных методов, таких как установка фона, шрифта и границ.

43. Платформа JavaFX, особенности, компоненты
JavaFX — это современная платформа для разработки графических пользовательских интерфейсов (GUI) в Java.
Особенности:
•	Поддерживает декларативный стиль (FXML).
•	Использует сценографическую графику для создания гибких интерфейсов.
•	Поддержка CSS для стилизации.
•	Интеграция с мультимедиа (видео, аудио).
•	Кроссплатформенность (работает на Windows, macOS, Linux).
Компоненты:
•	Stage (сцена) — основной контейнер приложения.
•	Scene (сцена) — пространство, где размещаются элементы.
•	Node (узел) — базовый элемент интерфейса (кнопки, текстовые поля и т. д.).
•	Controls — стандартные элементы управления (Button, TextField и т. д.).
44. Шаблон MVC (Model-View-Controller) в Spring
MVC (Model-View-Controller) — это архитектурный шаблон, разделяющий логику приложения:
•	Model — отвечает за бизнес-логику и данные. Пример: сервисы и сущности.
•	View — отвечает за отображение данных пользователю. Пример: HTML-страницы с Thymeleaf.
•	Controller — обрабатывает запросы от пользователя, взаимодействует с моделью и передает данные в представление.
В Spring MVC используется аннотация @Controller для создания контроллеров, а маршруты запросов задаются с помощью @RequestMapping или @GetMapping.
45. Классы StringBuffer и StringBuilder
Классы StringBuffer и StringBuilder используются для работы с изменяемыми строками в Java.
•	StringBuffer — потокобезопасный, то есть поддерживает синхронизацию и может использоваться в многопоточных приложениях. Это делает его чуть более медленным по сравнению с StringBuilder.
•	StringBuilder — не потокобезопасный, но быстрее StringBuffer. Его используют в однопоточных приложениях, где нет необходимости в синхронизации.
Оба класса позволяют изменять строки с помощью таких методов, как добавление текста, вставка, удаление и реверс строки. Например, можно добавлять текст в конец строки, вставлять текст в определенную позицию или удалять его.
47. Массивы Java: объявление, инициализация. Основные методы класса Arrays. Доступ к элементам массивов, итерация массивов. Двумерные массивы
Массивы в Java используются для хранения фиксированного количества элементов одного типа.
•	Объявление и инициализация: массив можно объявить, указав тип элементов и размер массива. Сразу после объявления элементы массива содержат значения по умолчанию. Также можно объявить массив с уже известными значениями.
•	Основные методы класса Arrays:
1.	Сортировка массива.
2.	Преобразование массива в строку для удобного отображения.
3.	Поиск элемента в отсортированном массиве.
•	Доступ к элементам и итерация: элементы массива доступны через их индексы, начиная с нуля. Чтобы просмотреть все элементы массива, можно использовать циклы.
•	Двумерные массивы: это массив массивов, где элементы хранятся в виде таблицы с строками и столбцами. Для работы с ними применяются вложенные циклы.
48. Иерархия наследования Java. Преобразование типов при наследовании. Ключевое слово instanceof.
Иерархия наследования — это механизм объектно-ориентированного программирования, который позволяет одному классу (наследнику) получать свойства и методы другого класса (родителя).
•	В Java все классы, прямо или косвенно, наследуются от класса Object, который является корнем иерархии.
•	Ключевые преимущества наследования: повторное использование кода, упрощение сопровождения и расширяемость программ.
Преобразование типов при наследовании:
1.	Унисходящее преобразование (upcasting) — преобразование от подкласса к базовому классу. Оно происходит автоматически. Например, объект подкласса может быть обработан как объект родительского класса.
2.	Нисходящее преобразование (downcasting) — преобразование от базового класса к подклассу. Требует явного указания типа. Если преобразование невозможно, возникает ошибка.
Ключевое слово instanceof используется для проверки, принадлежит ли объект конкретному классу или реализует ли интерфейс. Это помогает избежать ошибок преобразования типов.
49. Интерфейсы Java: определение интерфейса, реализация интерфейса. Преимущества применения интерфейсов. Переменные интерфейсов. Наследование интерфейсов. Методы по умолчанию. Статические методы интерфейсов.
Интерфейс — это контракт, определяющий набор методов без их реализации. Реализация интерфейсов осуществляется в классах, которые обязаны предоставить реализацию всех методов интерфейса.
Преимущества применения интерфейсов:
•	Позволяют добиться полной абстракции.
•	Поддерживают множественное наследование, так как класс может реализовывать несколько интерфейсов.
•	Повышают гибкость кода за счет слабой связанности.
Переменные интерфейсов:
Переменные в интерфейсах по умолчанию являются public static final, то есть константами.
Наследование интерфейсов:
Интерфейсы могут наследовать другие интерфейсы. При этом дочерний интерфейс добавляет или переопределяет методы.
Методы по умолчанию:
С Java 8 интерфейсы могут содержать методы с реализацией. Такие методы отмечаются ключевым словом default. Это позволяет добавлять новые методы в интерфейсы без необходимости изменять классы, их реализующие.
Статические методы интерфейсов:
С Java 8 интерфейсы также поддерживают статические методы, которые принадлежат интерфейсу и вызываются через его имя.
50. Байтовые потоки InputStream и OutputStream. Консольный ввод и вывод Java. Символьные потоки данных. Абстрактные классы Writer, Reader.
Байтовые потоки (InputStream и OutputStream):
•	InputStream используется для чтения данных в виде байтов (например, из файла или сети).
•	OutputStream используется для записи данных в виде байтов (например, в файл или консоль).
Байтовые потоки подходят для обработки двоичных данных (изображений, видео, аудио).
Консольный ввод и вывод:
Для консольного ввода используется класс Scanner, а для вывода — System.out. Это самый простой способ взаимодействия пользователя с приложением.
Символьные потоки данных:
Для работы с текстом (символами) в Java существуют символьные потоки. Они работают с char вместо байтов.
•	Классы Reader и Writer — это абстрактные базовые классы для работы с символьными данными.
•	Примеры их потомков: FileReader и FileWriter.
Символьные потоки удобны для обработки текстов, поскольку учитывают кодировку.
51. Основные фреймворки и задачи, решаемые Spring.
Spring — это популярный фреймворк для разработки приложений на Java. Его основные модули и задачи:
1.	Spring Core: реализация контейнера Inversion of Control (IoC) и управление зависимостями (Dependency Injection).
2.	Spring MVC: создание веб-приложений с использованием шаблона MVC.
3.	Spring Data: упрощение работы с базами данных, поддержка JPA, MongoDB и других.
4.	Spring Security: обеспечение безопасности приложений (аутентификация, авторизация).
5.	Spring Boot: упрощение создания приложений за счет готовой конфигурации.
6.	Spring Cloud: инструменты для разработки микросервисов.
Фреймворк повышает продуктивность, облегчает поддержку приложений и упрощает интеграцию с другими технологиями.
52. Spring Inversion of Control (IoC) контейнер Spring.
IoC (Inversion of Control) — это принцип, при котором управление зависимостями объектов передается контейнеру.
В Spring этот принцип реализован через IoC-контейнер, который:
1.	Создает объекты и управляет их жизненным циклом.
2.	Обеспечивает внедрение зависимостей (Dependency Injection).
3.	Управляет конфигурацией приложения через файлы XML, аннотации или Java-код.
Типы внедрения зависимостей:
•	Через конструктор — зависимости передаются в конструкторе.
•	Через сеттеры — зависимости устанавливаются с помощью методов.
IoC-контейнер является ключевой частью Spring и упрощает работу с объектами и их взаимодействием.
53. Dependency Injection (DI) в Spring
Dependency Injection (внедрение зависимостей) — это процесс, при котором зависимости объекта передаются ему извне, а не создаются внутри объекта.
Виды DI в Spring:
1.	Внедрение через конструктор — зависимости передаются через параметры конструктора.
2.	Внедрение через сеттеры — зависимости устанавливаются с помощью методов.
3.	Внедрение через поле (не рекомендуется) — зависимости задаются напрямую в поле класса.
Преимущества DI:
•	Ослабление связности между компонентами.
•	Упрощение тестирования (можно использовать заглушки).
•	Повышение гибкости и масштабируемости приложения.
Spring использует IoC-контейнер для автоматической настройки зависимостей, что позволяет разработчику сосредоточиться на логике приложения.
54. Жизненный цикл объекта Bean Spring
Объекты Bean в Spring управляются IoC-контейнером. Их жизненный цикл состоит из следующих этапов:
1.	Создание: контейнер создает объект Bean с помощью конструктора.
2.	Внедрение зависимостей: зависимости Bean задаются контейнером.
3.	Настройка Bean: вызываются методы настройки (@PostConstruct или метод init).
4.	Использование: Bean используется приложением.
5.	Завершение работы: при завершении работы контейнера вызываются методы уничтожения (@PreDestroy или метод destroy).
55. Конфигурация ApplicationContext с помощью XML в Spring
ApplicationContext — это интерфейс для работы с IoC-контейнером Spring. Конфигурация через XML выполняется следующим образом:
1.	Создание XML-файла конфигурации:
o	Указывается описание Bean, их классов и зависимостей.
o	Используются теги <bean> для настройки компонентов.
2.	Подключение ApplicationContext:
o	Приложение загружает XML-файл для получения данных о Bean.
3.	Управление Bean: контейнер создает и управляет объектами согласно настройкам в XML-файле.
XML-конфигурация используется реже с появлением аннотаций, но все еще поддерживается.
56. Область видимости Bean в Spring
Область видимости Bean (scope) определяет, сколько экземпляров Bean будет создано IoC-контейнером. В Spring доступны следующие области видимости:
1.	Singleton (по умолчанию): создается один экземпляр Bean на контейнер.
2.	Prototype: создается новый экземпляр Bean при каждом запросе.
3.	Request: Bean существует в течение одного HTTP-запроса (для веб-приложений).
4.	Session: Bean сохраняется в течение одной HTTP-сессии.
5.	GlobalSession: используется для портлетов (редко используется).
Область видимости задается с помощью аннотации @Scope или в XML-конфигурации.
57. Фабричные или factory-методы в Spring
Фабричные методы используются для создания объектов Bean. Они позволяют создавать объекты через вызов метода, а не напрямую через конструктор.
Типы фабричных методов в Spring:
1.	Статические фабричные методы:
o	Метод, который возвращает объект Bean, является статическим.
o	Указывается в XML-конфигурации с помощью атрибута factory-method.
2.	Нестатические фабричные методы:
o	Метод для создания объекта Bean принадлежит другому Bean.
o	Указывается в конфигурации через атрибуты factory-bean и factory-method.
Фабричные методы помогают реализовать гибкое создание объектов, особенно если их создание требует дополнительной логики или сложной настройки.
58. Конфигурация ApplicationContext с помощью аннотаций в Spring
Для конфигурации ApplicationContext с помощью аннотаций Spring предлагает подход Java-based Configuration, который позволяет отказаться от XML-файлов.
Основные аннотации:
•	@Configuration: указывает, что класс содержит определения Bean.
•	@Bean: помечает метод, возвращающий Bean, который будет управляться Spring.
•	@ComponentScan: сообщает контейнеру, где искать компоненты (классы, помеченные аннотациями, такими как @Component, @Service, @Repository, @Controller).
Преимущества аннотаций:
•	Упрощение конфигурации.
•	Код становится более читаемым и компактным.
•	Позволяет объединять конфигурацию и логику в одном месте.
59. Связывание в Spring, аннотация @Autowired
Связывание (Wiring) — это процесс автоматического сопоставления зависимостей между объектами в IoC-контейнере.
Аннотация @Autowired используется для автоматического внедрения зависимостей:
•	Она указывает контейнеру, что необходимо найти подходящий Bean и связать его с текущим компонентом.
•	Может применяться к полям, конструкторам или методам.
Типы автосвязывания:
•	По типу: внедрение осуществляется на основе типа Bean.
•	По имени (в XML-конфигурации).
При наличии нескольких подходящих Bean можно использовать аннотацию @Qualifier для указания имени нужного компонента.
60. Архитектурный стиль REST
REST (Representational State Transfer) — это архитектурный стиль для создания веб-сервисов, использующий HTTP-протокол.
Основные принципы REST:
1.	Ресурсо-ориентированность: данные представляются как ресурсы (например, users, orders).
2.	Унифицированный интерфейс: для работы с ресурсами используются HTTP-методы:
o	GET — получение данных.
o	POST — создание новых данных.
o	PUT — обновление существующих данных.
o	DELETE — удаление данных.
3.	Без состояния (stateless): сервер не хранит состояния клиента между запросами.
4.	Поддержка различных форматов данных: обычно используется JSON или XML.
REST облегчает интеграцию между системами и подходит для микросервисной архитектуры.
61. Spring Web-MVC, основная схема и логика работы
Spring Web-MVC — это модуль Spring для создания веб-приложений на основе шаблона Model-View-Controller (MVC).
Основная схема работы:
1.	Клиент отправляет запрос на сервер.
2.	DispatcherServlet принимает запрос и направляет его в обработчик.
3.	Контроллер (Controller) обрабатывает запрос и взаимодействует с моделью (данными).
4.	Результаты передаются в представление (View), которое формирует ответ для клиента.
Основные компоненты:
•	DispatcherServlet: центральный компонент, управляющий маршрутизацией запросов.
•	Контроллеры: классы, аннотированные @Controller, обрабатывают запросы.
•	ViewResolver: отвечает за выбор подходящего представления.
•	Model: объект, передающий данные между контроллером и представлением.
62. Класс DispatcherServlet, его функции
DispatcherServlet — это центральный компонент Spring Web-MVC, который управляет обработкой запросов.
Основные функции:
1.	Принимает HTTP-запросы и определяет, как их обработать.
2.	Передает запросы в контроллеры, согласно конфигурации маппинга.
3.	Обрабатывает исключения, если они возникают.
4.	Передает данные из контроллеров в представления (например, JSP или HTML).
5.	Выполняет интеграцию между компонентами, такими как ViewResolver, HandlerMapping и ModelAndView.
63. Маппинг в Spring
Маппинг (mapping) в Spring — это процесс сопоставления HTTP-запросов с методами контроллеров.
Для маппинга используется аннотация @RequestMapping (и ее сокращенные версии, такие как @GetMapping, @PostMapping):
•	@RequestMapping: указывает URL и HTTP-метод, которые должен обрабатывать метод контроллера.
•	@PathVariable: позволяет извлекать значения из URL.
•	@RequestParam: используется для получения параметров из строки запроса.
HandlerMapping — это компонент Spring, который определяет, какой метод контроллера будет обрабатывать запрос.
Маппинг позволяет организовать логику приложения, распределяя запросы между разными методами и контроллерами.
64. Интерфейсы HttpServletRequest и HttpServletResponse.
Интерфейсы HttpServletRequest и HttpServletResponse являются ключевыми компонентами Java Servlet API, которые используются для обработки HTTP-запросов и формирования HTTP-ответов в веб-приложениях на основе Java.
HttpServletRequest
HttpServletRequest представляет HTTP-запрос и предоставляет методы для получения информации о запросе.
Основные методы:
Параметры запроса:
•	String getParameter(String name): Получает значение параметра.
•	Map<String, String[]> getParameterMap(): Возвращает все параметры.
Информация о запросе:
•	String getMethod(): Возвращает HTTP-метод (GET, POST и т.д.).
•	String getRequestURI(): Возвращает URI запроса.
Заголовки:
•	String getHeader(String name): Получает значение заголовка. 
•	Enumeration<String> getHeaderNames(): Возвращает все имена заголовков.
Сессии: 
•	HttpSession getSession(): Возвращает объект сессии.
HttpServletResponse 
HttpServletResponse используется для формирования и отправки HTTP-ответа. 
Основные методы: 
Статус ответа: 
•	void setStatus(int sc): Устанавливает статус-код. 
•	void sendError(int sc): Отправляет ошибку. 
Заголовки: 
•	void setHeader(String name, String value): Устанавливает заголовок. 
•	void addHeader(String name, String value): Добавляет заголовок. 
Тип содержимого: 
•	void setContentType(String type): Устанавливает MIME-тип. 
Запись ответа: 
•	PrintWriter getWriter(): Получает объект для записи текста. 
•	ServletOutputStream getOutputStream(): Получает объект для записи бинарных данных. 
Перенаправление: 
•	void sendRedirect(String location): Перенаправляет клиента.

65. Архитектурный стиль CRUD, его соответствие REST и HTTP. 
Архитектурный стиль CRUD 
CRUD (Create, Read, Update, Delete) — это базовый архитектурный стиль, который описывает четыре основные операции, выполняемые над данными в приложениях. Эти операции соответствуют основным действиям, которые можно выполнять с ресурсами в системах управления базами данных (СУБД) и веб-приложениях. 
Основные операции CRUD: 
•	Create (Создание): Добавление нового ресурса или записи в систему. 
•	Read (Чтение): Получение данных о ресурсе или записи. 
•	Update (Обновление): Изменение существующего ресурса или записи. 
•	Delete (Удаление): Удаление ресурса или записи из системы. 
Соответствие CRUD, REST и HTTP 
REST (Representational State Transfer) — это архитектурный стиль, который использует HTTP-протокол для взаимодействия с ресурсами. В RESTful API CRUD-операции соответствуют HTTP-методам следующим образом: 
•	Create: соответствует методу POST. Используется для создания нового ресурса. 
•	Read: соответствует методу GET. Используется для получения данных о ресурсе. 
•	Update: соответствует методу PUT (или PATCH). Используется для обновления существующего ресурса. 
•	Delete: соответствует методу DELETE. Используется для удаления ресурса. 
Пример соответствия: 
•	POST /users — создание нового пользователя (Create). 
•	GET /users/1 — получение информации о пользователе с ID 1 (Read). 
•	PUT /users/1 — обновление информации о пользователе с ID 1 (Update). 
•	DELETE /users/1 — удаление пользователя с ID 1 (Delete).
66. Шаблон Data Access Object (DAO). 
Шаблон Data Access Object (DAO) 
Шаблон DAO (Data Access Object) — это структурный шаблон проектирования, который используется для абстракции и инкапсуляции доступа к данным. Он разделяет бизнес-логику приложения и логику доступа к данным, что упрощает управление и тестирование кода. 
Основные компоненты DAO: 
•	DAO интерфейс: Определяет методы для выполнения CRUD-операций. 
•	DAO реализация: Реализует интерфейс и содержит конкретные операции доступа к данным (например, с использованием JDBC, Hibernate и т.д.). 
•	Модель данных: Представляет сущности, с которыми работает DAO (например, класс User ).
67.	Основные понятия Объектно-реляционного отображения (ORM - Object-Relational Mapping). 
Объектно-реляционное отображение (ORM, Object-Relational Mapping) — это концепция и технология, позволяющая разработчикам работать с базами данных, используя объектно-ориентированные подходы. ORM служит мостом между объектно-ориентированным программированием и реляционными базами данных, позволяя разработчикам манипулировать данными в виде объектов, а не в виде строк и таблиц. 
Основные понятия ORM 
•	Объект: В контексте ORM объект — это экземпляр класса, который представляет сущность в приложении. Например, класс User  может представлять пользователя в системе. 
•	Сущность: Сущность — это объект, который имеет уникальный идентификатор и может быть сохранен в базе данных. Сущности обычно соответствуют таблицам в реляционной базе данных. 
•	Свойства (атрибуты): Свойства объекта соответствуют столбцам таблицы в базе данных. Например, класс User  может иметь свойства id, name, email, которые соответствуют столбцам в таблице users. 
•	Сессия: Сессия — это объект, который управляет взаимодействием между приложением и базой данных. Она используется для выполнения операций CRUD (Create, Read, Update, Delete) и управления транзакциями. 
•	Транзакция: Транзакция — это последовательность операций, которые выполняются как единое целое. Если одна из операций не удается, все изменения могут быть отменены, что обеспечивает целостность данных. 
•	Запросы: ORM позволяет выполнять запросы к базе данных с использованием объектно-ориентированного синтаксиса, что упрощает работу с данными. Запросы могут быть выполнены с помощью методов, предоставляемых ORM-фреймворком. 
•	Отображение (Mapping): Отображение — это процесс связывания объектов с таблицами базы данных. ORM-фреймворки используют метаданные (например, аннотации или XML-конфигурации) для определения, как классы и их свойства соответствуют таблицам и столбцам.
68.	Спецификация Java Persistence API (JPA). 
Спецификация Java Persistence API (JPA) 
Java Persistence API (JPA) — это спецификация, которая определяет стандартный способ работы с объектно-реляционным отображением (ORM) в Java-приложениях. JPA позволяет разработчикам управлять персистентными данными, используя объектно-ориентированные подходы. 
Основные компоненты JPA 
•	Сущности (Entities): Классы, представляющие таблицы в базе данных. Аннотируются с помощью @Entity, @Table, @Id и других. 
•	Контекст персистентности (Persistence Context): Среда, в которой управляются сущности. Отслеживает изменения и синхронизирует их с базой данных. 
•	EntityManager: Основной интерфейс JPA для управления сущностями. Методы: persist(), find(), merge(), remove(). 
•	Запросы (Queries): JPA поддерживает JPQL (Java Persistence Query Language) для выполнения запросов к сущностям, а также нативные SQL-запросы. 
•	Транзакции: JPA управляет транзакциями, обеспечивая целостность данных. 
•	Кэширование: Поддержка кэширования для повышения производительности. 
Основные аннотации JPA 
•	@Entity: Обозначает класс как сущность. 
•	@Table: Указывает таблицу, соответствующую сущности. 
•	@Id: Указывает первичный ключ. 
•	@GeneratedValue: Определяет стратегию генерации ключа. 
•	@Column: Указывает параметры для столбца. 
•	@OneToMany, @ManyToOne, и другие: Определяют отношения между сущностями.
69.	Архитектура ORM Java Persistence API (JPA). 
Архитектура ORM Java Persistence API (JPA) 
Java Persistence API (JPA) — это спецификация, которая определяет архитектуру для работы с объектно-реляционным отображением (ORM) в Java-приложениях. JPA позволяет разработчикам управлять персистентными данными, используя объектно-ориентированные подходы, и обеспечивает абстракцию над реляционными базами данных. Рассмотрим основные компоненты и архитектурные элементы JPA. 
Основные компоненты архитектуры JPA 
•	Сущности (Entities): Сущности представляют собой классы, которые соответствуют таблицам в базе данных. Каждый экземпляр сущности соответствует строке в таблице. Сущности аннотируются с помощью аннотаций JPA, таких как @Entity, @Table, @Id, и других. 
•	EntityManager: EntityManager — это основной интерфейс JPA, который управляет жизненным циклом сущностей. Он предоставляет методы для выполнения операций CRUD (Create, Read, Update, Delete). EntityManager работает в контексте персистентности и отслеживает изменения в сущностях. 
•	Контекст персистентности (Persistence Context): Контекст персистентности — это среда, в которой управляются сущности. Он отслеживает состояние сущностей и синхронизирует их с базой данных. Контекст может быть управляемым контейнером (например, в Java EE) или программным (например, в Java SE). 
•	Транзакции: JPA управляет транзакциями, обеспечивая целостность данных. Транзакции могут быть управляемыми контейнером или программно. Используются методы begin(), commit(), и rollback() для управления транзакциями. 
•	Запросы (Queries): JPA поддерживает JPQL (Java Persistence Query Language) для выполнения запросов к сущностям. JPQL позволяет писать запросы, используя объектно-ориентированный синтаксис. Также поддерживаются нативные SQL-запросы, что позволяет выполнять сложные операции, которые могут быть трудными для реализации с помощью JPQL. 
•	Кэширование: JPA поддерживает кэширование, что позволяет улучшить производительность приложения, уменьшая количество обращений к базе данных. Кэш может быть как на уровне сущностей, так и на уровне запросов. 
•	Провайдеры JPA: JPA является спецификацией, и для ее реализации существуют различные провайдеры, такие как Hibernate, EclipseLink, OpenJPA и другие. Каждый провайдер может иметь свои особенности и расширения, но все они соответствуют спецификации JPA.
70.	Основные аннотации Java Persistence API (JPA). 
Основные аннотации Java Persistence API (JPA) 
Java Persistence API (JPA) использует аннотации для определения метаданных, которые описывают, как классы и их свойства соответствуют таблицам и столбцам в реляционной базе данных.
1.	Аннотации для определения сущностей 
•	@Entity: Обозначает класс как сущность, которая будет отображаться в таблице базы данных. 
•	@Table: Указывает, какая таблица в базе данных соответствует сущности. Можно задать имя таблицы и другие параметры. 
2.	Аннотации для идентификаторов 
•	@Id: Указывает, какой атрибут является первичным ключом сущности.
•	@GeneratedValue: Определяет стратегию генерации значений для первичного ключа (например, автоинкремент). 
3.	Аннотации для свойств 
•	@Column: Указывает дополнительные параметры для столбца, такие как имя, уникальность и длина. 
•	@Transient: Указывает, что поле не должно быть сохранено в базе данных. 
4.	Аннотации для отношений 
•	@OneToOne: Определяет отношение "один к одному" между двумя сущностями. @OneToMany: Определяет отношение "один ко многим". 
•	@ManyToOne: Определяет отношение "многие к одному". 
•	@ManyToMany: Определяет отношение "многие ко многим". 
5.	Аннотации для управления жизненным циклом 
•	@PrePersist: Метод, вызываемый перед сохранением сущности. 
•	@PostPersist: Метод, вызываемый после сохранения сущности. 
•	@PreUpdate: Метод, вызываемый перед обновлением сущности. 
•	@PostRemove: Метод, вызываемый после удаления сущности.
71.	Библиотека Hibernate, основные аннотации. 
Библиотека Hibernate и основные аннотации 
Hibernate — это один из самых популярных фреймворков для объектно-реляционного отображения (ORM) в Java. Он реализует спецификацию Java Persistence API (JPA) и предоставляет дополнительные возможности для работы с базами данных. Hibernate упрощает взаимодействие между объектами Java и реляционными базами данных, позволяя разработчикам сосредоточиться на бизнес-логике, а не на SQL-запросах.
Основные аннотации Hibernate 
Hibernate использует аннотации, которые могут быть как частью JPA, так и специфичными для Hibernate. Вот некоторые из них: 
•	@Entity: Обозначает класс как сущность, которая будет отображаться в таблице базы данных. 
•	@Table: Указывает, какая таблица в базе данных соответствует сущности. Можно задать имя таблицы и другие параметры. 
•	@Id: Указывает, какой атрибут является первичным ключом сущности. 
•	@GeneratedValue: Определяет стратегию генерации значений для первичного ключа (например, автоинкремент). 
•	@Column: Указывает дополнительные параметры для столбца, такие как имя, уникальность и длина. 
•	@OneToOne: Определяет отношение "один к одному" между двумя сущностями. 
•	@OneToMany: Определяет отношение "один ко многим". 
•	@ManyToOne: Определяет отношение "многие к одному". 
•	@ManyToMany: Определяет отношение "многие ко многим". 
•	@Fetch: Определяет стратегию загрузки для ассоциаций (например, FetchType.LAZY или FetchType.EAGER). 
•	@Cascade: Указывает, какие операции каскадно применяются к связанным сущностям (например, CascadeType.ALL). 
•	@Transient: Указывает, что поле не должно быть сохранено в базе данных.
72.	Объявление сущности и таблицы в Hibernate. 
В Hibernate сущности представляют собой классы, которые отображаются на таблицы в реляционной базе данных. Для объявления сущности и соответствующей таблицы используются аннотации. 
Объявление сущности 
Аннотация @Entity указывает, что класс является сущностью, а аннотация @Table задает имя таблицы, соответствующей этой сущности.
Объявление сущности и таблицы в Hibernate позволяет разработчикам легко связывать классы Java с таблицами в базе данных, упрощая управление персистентными данными.
73.	Интерфейс Session в Hibernate. 
Интерфейс Session в Hibernate 
Интерфейс Session в Hibernate является основным инструментом для взаимодействия с базой данных. Он управляет жизненным циклом сущностей, транзакциями и запросами. 
Основные функции интерфейса Session 
•	Управление сущностями: Сохранение, обновление, удаление и извлечение сущностей. 
•	Управление транзакциями: Начало, завершение и откат транзакций. 
•	Кэширование: Использует кэш первого уровня для хранения сущностей в памяти. 
•	Запросы: Выполнение запросов с использованием HQL и Criteria API. 
Основные методы интерфейса Session 
•	save(Object entity): Сохраняет сущность в базе данных. 
•	update(Object entity): Обновляет существующую сущность. 
•	delete(Object entity): Удаляет сущность из базы данных. 
•	Get(Class<T> clazz, Serializable id): Извлекает сущность по идентификатору. 
•	beginTransaction(): Начинает новую транзакцию. 
•	createQuery(String hql): Создает HQL-запрос. 
•	close(): Закрывает сессию и освобождает ресурсы.
74.	Ассоциация сущностей в Hibernate. 
Ассоциация сущностей в Hibernate 
Ассоциации сущностей в Hibernate описывают, как различные сущности связаны друг с другом в реляционной базе данных. Основные типы ассоциаций включают "один к одному", "один ко многим", "многие к одному" и "многие ко многим". 
•	Один к одному (One-to-One) Одна сущность связана с одной другой сущностью. Например, у пользователя может быть один профиль.
•	Один ко многим (One-to-Many) Одна сущность может быть связана с несколькими другими сущностями. Например, один пользователь может иметь несколько заказов.
•	Многие к одному (Many-to-One) Несколько сущностей могут ссылаться на одну и ту же сущность. Например, несколько заказов могут принадлежать одному пользователю. 
•	Многие ко многим (Many-to-Many) Одна сущность может быть связана с несколькими другими сущностями, и наоборот. Например, пользователи могут иметь несколько ролей.
Ассоциации сущностей в Hibernate позволяют моделировать взаимосвязи между объектами, что упрощает управление данными и поддерживает целостность базы данных.
75.	Spring Boot: определение, характеристики, преимущества. 
Определение 
Spring Boot — это фреймворк на основе Spring, который упрощает разработку и развертывание Java-приложений, позволяя быстро создавать автономные и производительные приложения. 
Характеристики 
•	Автоконфигурация: Автоматическая настройка приложения на основе зависимостей. 
•	Стартовые зависимости: Наборы зависимостей для различных задач (например, spring-boot-starter-web). 
•	Встроенные серверы: Поддержка встроенных серверов (Tomcat, Jetty), что упрощает запуск приложений. 
•	Простота развертывания: Легкое упаковывание в исполняемые JAR-файлы. 
•	Поддержка микросервисов: Идеален для разработки микросервисов. 
•	Инструменты мониторинга: Встроенные инструменты для мониторинга и управления приложениями. 
Преимущества 
•	Ускорение разработки: Быстрая настройка и разработка приложений. 
•	Легкость в использовании: Простота настройки делает его доступным для всех уровней разработчиков. 
•	Гибкость: Легкая настройка и расширяемость приложений. 
•	Сообщество и поддержка: Широкое сообщество и обширная документация. 
•	Производительность: Оптимизирован для создания масштабируемых приложений.
76	Spring Initializr, особенности и преимущества применения. 
Spring Initializr — это веб-инструмент, который упрощает создание новых проектов на основе фреймворка Spring, позволяя быстро настраивать и генерировать проект с необходимыми зависимостями. 
Особенности Spring Initializr 
•	Интуитивный интерфейс: Простой и понятный интерфейс, доступный даже для новичков. 
•	Настройка проекта: Возможность выбора типа проекта (Maven или Gradle), языка (Java, Kotlin, Groovy) и версии Spring Boot. 
•	Выбор зависимостей: Легкий выбор необходимых зависимостей, таких как Spring Web, Spring Data JPA и другие. 
•	Генерация проекта: Создание ZIP-архива с готовой структурой проекта, который можно сразу использовать. 
•	Поддержка версий: Возможность выбора различных версий Spring Boot. 
•	Интеграция с IDE: Легкий импорт сгенерированного проекта в популярные IDE. 
Преимущества применения Spring Initializr 
•	Скорость разработки: Ускоряет процесс создания проекта, позволяя сосредоточиться на бизнес-логике. 
•	Минимизация ошибок: Снижает вероятность ошибок в конфигурации. 
•	Гибкость: Позволяет создавать проекты, соответствующие конкретным требованиям. 
•	Упрощение обучения: Доступный инструмент для новичков, облегчающий процесс обучения. 
•	Сообщество и поддержка: Часть экосистемы Spring с большим сообществом и ресурсами. 
•	Совместимость: Генерируемые проекты соответствуют современным стандартам разработки.
77	Структура фреймворка JUnit. 
JUnit — это популярный фреймворк для модульного тестирования в Java, который помогает разработчикам писать и выполнять тесты для проверки функциональности кода. 
Основные компоненты структуры JUnit 
Аннотации: 
•	@Test: Обозначает тестовый метод. 
•	@Before и @After: Выполняются перед и после каждого теста соответственно. 
•	@BeforeClass и @AfterClass: Выполняются один раз перед и после всех тестов в классе. 
•	@Ignore: Отключает тест. 
Классы тестов: Тесты организуются в классы, каждый из которых содержит методы с аннотацией @Test. 
Ассерты: Класс Assert предоставляет методы для проверки условий, такие как assertEquals(), assertTrue(), и assertFalse(). 
Тестовые наборы (Test Suites): Позволяют группировать несколько тестовых классов для совместного выполнения с помощью аннотации @Suite. 
Запуск тестов: Тесты можно запускать из IDE или командной строки с использованием Maven или Gradle. 
Расширяемость: JUnit поддерживает создание пользовательских правил и расширений для добавления дополнительной функциональности. 
Преимущества использования JUnit 
	Упрощение тестирования: Простые инструменты для написания тестов. 
	Автоматизация: Быстрое выполнение тестов при изменениях в коде. 
	Поддержка TDD: Способствует созданию качественного кода. 
	Сообщество: Большое количество ресурсов и поддержка.
78	JUnit аннотации @Test, @DisplayName. 
JUnit — это популярный фреймворк для тестирования в Java, который позволяет разработчикам писать и выполнять тесты для проверки корректности работы их кода. Две важные аннотации в JUnit — это @Test и @DisplayName.
Аннотация @Test 
Назначение: Используется для обозначения метода как теста. Метод, помеченный этой аннотацией, будет выполнен как тестовый случай.
Пример использования:
import org.junit.jupiter.api.Test; 
public class MyTests { 
@Test 
void testAddition() { 
int sum = 1 + 1; 
assertEquals(2, sum); 
} 
}
Особенности: 
	Метод, помеченный @Test, не должен возвращать значение и не должен принимать аргументы. 
	Если тест не проходит, JUnit сообщает об этом, и тест считается неуспешным.
Аннотация @DisplayName 
Назначение: Позволяет задать человекочитаемое имя для теста, которое будет отображаться в отчетах о тестировании. Это помогает сделать выводы более понятными и удобными для чтения. 
Пример использования:
import org.junit.jupiter.api.DisplayName; 
import org.junit.jupiter.api.Test; 
public class MyTests { 
@Test 
@DisplayName("Проверка сложения двух чисел") 
void testAddition() { 
int sum = 1 + 1; 
assertEquals(2, sum); 
} 
}
Особенности: Имя, заданное с помощью @DisplayName, может содержать пробелы и специальные символы, что позволяет создавать более описательные названия для тестов.
79	JUnit аннотации @BeforeEach, @AfterEach. 
Аннотация @BeforeEach 
Назначение: Метод, помеченный этой аннотацией, выполняется перед каждым тестовым методом в классе. Это позволяет подготовить необходимые ресурсы или установить начальное состояние, которое требуется для выполнения тестов. 
Применение: Используется для инициализации объектов, настройки окружения или выполнения других действий, которые должны происходить перед каждым тестом. 
Пример для @BeforeEach
import org.junit.jupiter.api.BeforeEach; 
import org.junit.jupiter.api.Test; 
public class MyTests { 
private int value; 
@BeforeEach 
void setUp() { 
value = 10; // Инициализация перед каждым тестом 
} 
@Test void testAddition() { 
assertEquals(15, value + 5); // Использует value, инициализированное в setUp 
} 
}
Аннотация @AfterEach 
Назначение: Метод, помеченный этой аннотацией, выполняется после каждого тестового метода в классе. Это позволяет выполнить очистку или освободить ресурсы, которые были задействованы в тестах. 
Применение: Используется для сброса состояния, освобождения ресурсов или выполнения других действий, которые должны происходить после каждого теста.
Пример для @AfterEach
import org.junit.jupiter.api.AfterEach; 
import org.junit.jupiter.api.Test; 
public class MyTests { 
private int value; 
@BeforeEach void setUp() { 
value = 10; // Инициализация перед каждым тестом 
} 
@AfterEach void tearDown() { 
value = 0; // Очистка состояния после каждого теста 
} 
@Test void testSubtraction() { 
assertEquals(5, value - 5); // Использует value, инициализированное в setUp 
} 
}
80	Тестовые классы и методы JUnit.
Тестовые классы 
Определение: Тестовый класс — это класс, содержащий тестовые методы для проверки функциональности определенного компонента приложения. 
Конвенция именования: Обычно именуются с добавлением суффикса Test к имени тестируемого класса (например, CalculatorTest). 
Структура: Может содержать несколько тестовых методов, а также методы для подготовки и очистки состояния (например, с использованием аннотаций @BeforeEach и @AfterEach). 
Тестовые методы 
Определение: Тестовый метод — это метод, помеченный аннотацией @Test, который проверяет конкретный аспект функциональности. 
Конвенция именования: Имеют описательные имена, отражающие проверяемую функциональность (например, testAddition). 
Структура: Не возвращают значение и не принимают аргументы. Внутри тестового метода выполняются проверки с использованием утверждений (assertions).
81	Утверждения JUnit. Класс Assert. 
Утверждения (assertions) в JUnit — это методы, которые используются для проверки ожидаемых результатов в тестах. Они позволяют разработчикам убедиться, что код работает так, как задумано, путем сравнения фактических значений с ожидаемыми. 
Класс Assert 
	Определение: Класс Assert предоставляет статические методы для выполнения утверждений в тестах. Эти методы позволяют проверять различные условия и сравнивать значения. 
	Импорт: В JUnit 5 класс Assert заменен на статические методы из класса Assertions, который находится в пакете org.junit.jupiter.api. 
Основные методы утверждений 
	assertEquals(expected, actual): Проверяет, что два значения равны. Если они не равны, тест завершается с ошибкой. 
	assertNotEquals(expected, actual): Проверяет, что два значения не равны. 
	assertTrue(condition): Проверяет, что условие истинно. 
	assertFalse(condition): Проверяет, что условие ложно. 
	assertNull(object): Проверяет, что объект равен null. 
	assertNotNull(object): Проверяет, что объект не равен null. 
	assertArrayEquals(expectedArray, actualArray): Проверяет, что два массива равны по содержимому.
Утверждения обычно используются внутри тестовых методов для проверки результатов выполнения кода. Например, после вызова метода, который должен вернуть определенное значение, можно использовать assertEquals для проверки, соответствует ли возвращаемое значение ожидаемому.
82	Тестирование исключений JUnit. 
Тестирование исключений в JUnit позволяет проверять, что методы выбрасывают ожидаемые исключения при возникновении ошибок или некорректных входных данных. Это важный аспект обеспечения надежности кода. 
Основные подходы к тестированию исключений 
	Аннотация @Test с параметром expected (JUnit 4): Позволяет указать ожидаемое исключение. Если метод выбрасывает это исключение, тест считается успешным. 
	Метод assertThrows (JUnit 5): Рекомендуется для проверки исключений. Он позволяет вызывать код и проверять, выбрасывается ли ожидаемое исключение, а также предоставляет возможность дополнительно проверять сообщение исключения. 
Преимущества тестирования исключений 
	Улучшение надежности: Убедитесь, что код корректно обрабатывает ошибки. 
	Документация поведения: Тесты служат документацией, показывая, как метод должен реагировать на некорректные входные данные.
83	Генератор документирования Javadoc. Виды комментариев. 
Javadoc — это инструмент, входящий в состав JDK, который автоматически генерирует документацию для Java-кода в формате HTML, используя специальные комментарии, называемые Javadoc-комментариями. 
Основные виды комментариев Javadoc 
	Комментарии для классов: Описывают назначение и функциональность класса. Размещаются перед объявлением класса. 
	Комментарии для методов: Описывают, что делает метод, его параметры, возвращаемое значение и возможные исключения. Размещаются перед объявлением метода. 
	Комментарии для полей: Описывают назначение и использование полей класса. Размещаются перед объявлением поля. 
	Теги для параметров и возвращаемых значений: 
•	@param: Описание параметров метода. 
•	@return: Описание возвращаемого значения. 
•	@throws или @exception: Описание исключений, которые может выбросить метод. 
	Теги для ссылок: 
•	@see: Указывает ссылки на другие классы или методы. 
•	@link: Вставляет ссылки в текст комментария.
84	Дескрипторы Javadoc. 
Дескрипторы Javadoc — это специальные теги и конструкции, используемые в Javadoc-комментариях для структурирования и улучшения документации, создаваемой из исходного кода Java. Они помогают разработчикам предоставлять более детальную и организованную информацию о классах, методах и полях, а также о других элементах кода. 
Основные дескрипторы Javadoc 
Теги для описания: 
•	@param: Описывает параметры метода. Указывает тип и назначение каждого параметра. 
•	@return: Описывает возвращаемое значение метода, указывая, что именно возвращает метод. 
•	@throws или @exception: Описывает исключения, которые может выбросить метод, что помогает пользователям понимать, какие ошибки могут возникнуть. 
Теги для ссылок: 
•	@see: Указывает на другие классы, методы или поля, которые могут быть полезны для понимания контекста. 
•	@link: Позволяет вставлять ссылки в текст комментария, что делает документацию более интерактивной. 
Теги для дополнительной информации: 
•	@deprecated: Указывает, что класс или метод устарел и не рекомендуется к использованию. Обычно сопровождается описанием альтернатив. 
•	@since: Указывает, начиная с какой версии библиотеки или приложения был добавлен класс или метод. 
•	@author: Указывает автора класса или метода, что может быть полезно для отслеживания изменений и поддержки кода. 
•	@version: Указывает версию класса или метода, что помогает в управлении версиями и изменениями. 
Теги для структурирования: 
•	@code и @endcode: Используются для выделения фрагментов кода в документации, что делает ее более читабельной. 
•	@literal: Позволяет вставлять текст, который не будет интерпретироваться как HTML или Javadoc-теги, что полезно для отображения специальных символов.


ЗАДАЧИ
1. Условие: «Реализовать программу для выполнения следующих математических операций с целочисленным, байтовым и вещественным типами данных: сложение, вычитание, умножение, деление, деление по модулю (остаток), модуль числа, возведение в степень. Все данные вводятся с клавиатуры (класс Scanner, System.in, nextint).» По данному условию необходимо реализовать программу с интерактивным консольным меню, (т.е. вывод списка действий по цифрам. При этом при нажатии на цифру у нас должно выполняться определенное действие). При этом в программе данные пункты должны называться следующим образом: 1. Вывести все таблицы из MySQL. 2. Создать таблицу в MySQL. 3. Сложение чисел, результат сохранить в MySQL с последующим выводом в консоль. 4. Вычитание чисел, результат сохранить в MySQL с последующим выводом в консоль. 5. Умножение чисел, результат сохранить в MySQL с последующим выводом в консоль. 6. Деление чисел, результат сохранить в MySQL с последующим выводом в консоль. 7. Деление чисел по модулю (остаток), результат сохранить в MySQL с последующим выводом в консоль. 8. Возведение числа в модуль, результат сохранить в MySQL с последующим выводом в консоль. 9. Возведение числа в степень, результат сохранить в MySQL с последующим выводом в консоль. 10. Сохранить все данные (вышеполученные результаты) из MySQL в Excel и вывести на экран.





import java.sql.*;
import java.util.Scanner;
import java.io.FileOutputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class MathOperationsWithMySQL {
    private static final String URL = "jdbc:mysql://localhost:3306/testdb";
    private static final String USER = "root";
    private static final String PASSWORD = "1234";

    public static void main(String[] args) throws Exception {
        Connection connection = DriverManager.getConnection(URL, USER, PASSWORD);
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("Меню:");
            System.out.println("1. Вывести все таблицы из MySQL");
            System.out.println("2. Создать таблицу в MySQL");
            System.out.println("3. Сложение чисел");
            System.out.println("4. Вычитание чисел");
            System.out.println("5. Умножение чисел");
            System.out.println("6. Деление чисел");
            System.out.println("7. Деление чисел по модулю (остаток)");
            System.out.println("8. Возведение числа в модуль");
            System.out.println("9. Возведение числа в степень");
            System.out.println("10. Сохранить данные в Excel");
            System.out.println("0. Выход");
            int choice = scanner.nextInt();

            if (choice == 0) break;

            switch (choice) {
                case 1:
                    DatabaseMetaData metaData = connection.getMetaData();
                    ResultSet tables = metaData.getTables(null, null, "%", new String[]{"TABLE"});
                    while (tables.next()) {
                        System.out.println(tables.getString("TABLE_NAME"));
                    }
                    break;
                case 2:
                    connection.createStatement().executeUpdate(
                            "CREATE TABLE IF NOT EXISTS results (" +
                                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                                    "operation VARCHAR(50), " +
                                    "result DOUBLE)");
                    System.out.println("Таблица создана.");
                    break;
                case 3:
                    performOperation(connection, scanner, "Сложение", (a, b) -> a + b);
                    break;
                case 4:
                    performOperation(connection, scanner, "Вычитание", (a, b) -> a - b);
                    break;
                case 5:
                    performOperation(connection, scanner, "Умножение", (a, b) -> a * b);
                    break;
                case 6:
                    performOperation(connection, scanner, "Деление", (a, b) -> a / b);
                    break;
                case 7:
                    performOperation(connection, scanner, "Деление по модулю", (a, b) -> a % b);
                    break;
                case 8:
                    System.out.print("Введите число: ");
                    double num = scanner.nextDouble();
                    double absResult = Math.abs(num);
                    saveResult(connection, "Модуль числа", absResult);
                    System.out.println("Результат: " + absResult);
                    break;
                case 9:
                    System.out.print("Введите число: ");
                    double base = scanner.nextDouble();
                    System.out.print("Введите степень: ");
                    double exp = scanner.nextDouble();
                    double powResult = Math.pow(base, exp);
                    saveResult(connection, "Возведение в степень", powResult);
                    System.out.println("Результат: " + powResult);
                    break;
                case 10:
                    saveToExcel(connection);
                    break;
                default:
                    System.out.println("Неверный выбор.");
            }
        }
        scanner.close();
        connection.close();
    }

    private static void performOperation(Connection connection, Scanner scanner, String operation, Operation op) throws SQLException {
        System.out.print("Введите первое число: ");
        double a = scanner.nextDouble();
        System.out.print("Введите второе число: ");
        double b = scanner.nextDouble();
        double result = op.calculate(a, b);
        saveResult(connection, operation, result);
        System.out.println("Результат: " + result);
    }

    private static void saveResult(Connection connection, String operation, double result) throws SQLException {
        PreparedStatement statement = connection.prepareStatement("INSERT INTO results (operation, result) VALUES (?, ?)");
        statement.setString(1, operation);
        statement.setDouble(2, result);
        statement.executeUpdate();
    }

    private static void saveToExcel(Connection connection) throws Exception {
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM results");
        Workbook workbook = new XSSFWorkbook();
        Sheet sheet = workbook.createSheet("Results");
        Row header = sheet.createRow(0);
        header.createCell(0).setCellValue("ID");
        header.createCell(1).setCellValue("Operation");
        header.createCell(2).setCellValue("Result");
        int rowIndex = 1;
        while (resultSet.next()) {
            Row row = sheet.createRow(rowIndex++);
            row.createCell(0).setCellValue(resultSet.getInt("id"));
            row.createCell(1).setCellValue(resultSet.getString("operation"));
            row.createCell(2).setCellValue(resultSet.getDouble("result"));
        }
        FileOutputStream fos = new FileOutputStream("results.xlsx");
        workbook.write(fos);
        fos.close();
        workbook.close();
        System.out.println("Данные сохранены в results.xlsx");
    }

    @FunctionalInterface
    interface Operation {
        double calculate(double a, double b);
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>untitled1</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.3</version> <!-- Укажите актуальную версию -->
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.20.0</version> <!-- Укажите последнюю стабильную версию -->
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.20.0</version>
        </dependency>
    </dependencies>


    <properties>
        <maven.compiler.source>23</maven.compiler.source>
        <maven.compiler.target>23</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>

2. Напишите программу, в которой из строки "I have 3 cats, 4 dogs, and 1 turtle" отбираются цифры. Из этих цифр формируется массив.
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        String input = "I have 3 cats, 4 dogs, and 1 turtle";
        ArrayList<Integer> digits = new ArrayList<>();

        for (char c : input.toCharArray()) {
            if (Character.isDigit(c)) {
                digits.add(Character.getNumericValue(c));
            }
        }

        int[] result = digits.stream().mapToInt(Integer::intValue).toArray();

        System.out.println("Массив цифр:");
        for (int num : result) {
            System.out.print(num + " ");
        }
    }
}

3. Разработайте программу, которая выводит в консоль все цифры, входящие в натуральное число n. К примеру, если дано число 2359, то в консоль выводятся отдельно числа 2, 3, 5, 9.

public class Main {
    public static void main(String[] args) {
        int n = 2359;

        // Преобразуем число в строку
        String numberString = Integer.toString(n);

        // Перебираем каждый символ строки и выводим его
        for (char digit : numberString.toCharArray()) {
            System.out.println(digit);
        }
    }
}


4. Написать калькулятор для строковых выражений вида " ", где - положительное целое число меньшее 10, записанное словами, например, "четыре", - одна из операций "плюс", "минус", "умножить". Результат выполнения операции вернуть в виде текстового представления числа. Пример: "пять плюс четыре" --> "девять".
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        String input = "пять плюс четыре";
        System.out.println(calculate(input));
    }

    public static String calculate(String input) {
        Map<String, Integer> numberMap = new HashMap<>();
        numberMap.put("один", 1);
        numberMap.put("два", 2);
        numberMap.put("три", 3);
        numberMap.put("четыре", 4);
        numberMap.put("пять", 5);
        numberMap.put("шесть", 6);
        numberMap.put("семь", 7);
        numberMap.put("восемь", 8);
        numberMap.put("девять", 9);

        Map<String, String> reverseNumberMap = new HashMap<>();
        reverseNumberMap.put("1", "один");
        reverseNumberMap.put("2", "два");
        reverseNumberMap.put("3", "три");
        reverseNumberMap.put("4", "четыре");
        reverseNumberMap.put("5", "пять");
        reverseNumberMap.put("6", "шесть");
        reverseNumberMap.put("7", "семь");
        reverseNumberMap.put("8", "восемь");
        reverseNumberMap.put("9", "девять");

        String[] parts = input.split(" ");
        int num1 = numberMap.get(parts[0]);
        int num2 = numberMap.get(parts[2]);
        String operation = parts[1];
        int result = 0;

        if (operation.equals("плюс")) {
            result = num1 + num2;
        } else if (operation.equals("минус")) {
            result = num1 - num2;
        } else if (operation.equals("умножить")) {
            result = num1 * num2;
        }

        return reverseNumberMap.get(String.valueOf(result));
    }
}



5.	Напишите программную реализацию бинарного дерева поиска.
6.	class BinarySearchTree {
    class Node {
        int value;
        Node left, right;

        Node(int item) {
            value = item;
            left = right = null;
        }
    }

    Node root;

    BinarySearchTree() {
        root = null;
    }

    void insert(int value) {
        root = insertRec(root, value);
    }

    Node insertRec(Node root, int value) {
        if (root == null) {
            root = new Node(value);
            return root;
        }
        if (value < root.value) {
            root.left = insertRec(root.left, value);
        } else if (value > root.value) {
            root.right = insertRec(root.right, value);
        }
        return root;
    }

    void inorder() {
        inorderRec(root);
    }

    void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.value + " ");
            inorderRec(root.right);
        }
    }

    Node search(Node root, int value) {
        if (root == null || root.value == value) {
            return root;
        }
        if (value < root.value) {
            return search(root.left, value);
        }
        return search(root.right, value);
    }

    public static void main(String[] args) {
        BinarySearchTree tree = new BinarySearchTree();
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        tree.inorder();

        Node result = tree.search(tree.root, 40);
        if (result != null) {
            System.out.println("\nFound: " + result.value);
        } else {
            System.out.println("\nNot Found");
        }
    }
}


6. Разработайте программу, которая выводит буквы английского алфавита, используя цикл while в MySQL/PostgreSQL.
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Main {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "root"; // Укажите вашего пользователя MySQL
        String password = "1234"; // Укажите ваш пароль MySQL

        try (Connection connection = DriverManager.getConnection(url, user, password);
             Statement statement = connection.createStatement()) {

            statement.execute("CREATE TABLE IF NOT EXISTS Alphabet (letter CHAR(1));");
            statement.execute("TRUNCATE TABLE Alphabet;");

            char letter = 'a';
            while (letter <= 'z') {
                statement.execute("INSERT INTO Alphabet (letter) VALUES ('" + letter + "');");
                letter++;
            }

            ResultSet resultSet = statement.executeQuery("SELECT * FROM Alphabet;");
            while (resultSet.next()) {
                System.out.println(resultSet.getString("letter"));
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>untitled2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.3</version> <!-- Укажите актуальную версию -->
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.20.0</version> <!-- Укажите последнюю стабильную версию -->
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.20.0</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>23</maven.compiler.source>
        <maven.compiler.target>23</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>
7. Напишите программу, которая будет выводить в консоль введённое слово 6 раз и сохранять в MySQL/PostgreSQL.

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "root"; // Укажите пользователя MySQL
        String password = "1234"; // Укажите пароль MySQL

        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите слово: ");
        String word = scanner.nextLine();

        try (Connection connection = DriverManager.getConnection(url, user, password)) {
            String createTableQuery = "CREATE TABLE IF NOT EXISTS Words (id INT AUTO_INCREMENT PRIMARY KEY, word VARCHAR(255));";
            connection.createStatement().execute(createTableQuery);

            String insertQuery = "INSERT INTO Words (word) VALUES (?);";
            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);

            for (int i = 0; i < 6; i++) {
                System.out.println(word);
                preparedStatement.setString(1, word);
                preparedStatement.executeUpdate();
            }

            System.out.println("Слово сохранено в базе данных 6 раз.");

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>untitled2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.3</version> <!-- Укажите актуальную версию -->
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.20.0</version> <!-- Укажите последнюю стабильную версию -->
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.20.0</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>23</maven.compiler.source>
        <maven.compiler.target>23</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>


8. Разработать программу для вывода на экран кубов первых десяти положительных чисел.
public class Main {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            System.out.println(i * i * i);
        }
    }
}


9. Напишите программу, которая по дате определяет день недели, на который эта дата приходится.

import java.time.LocalDate;
import java.time.DayOfWeek;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите дату (ГГГГ-ММ-ДД): ");
        String inputDate = scanner.nextLine();
        LocalDate date = LocalDate.parse(inputDate);
        DayOfWeek dayOfWeek = date.getDayOfWeek();
        System.out.println("День недели: " + dayOfWeek);
    }
}



10.	Написать класс, который при введении даты в формате ДД.ММ.ГГ (к примеру, 22.10.20) выводит номер недели. Даты начиная с 2020 по 2022 годы. К примеру, первая неделя в 2020 году: 1-5 января, вторая неделя – 6-12 января. Значит при вводе 08.01.20 вывод должен быть: Неделя 2.

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.WeekFields;
import java.util.Locale;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите дату в формате ДД.ММ.ГГ: ");
        String inputDate = scanner.nextLine();

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yy");
        LocalDate date = LocalDate.parse(inputDate, formatter);

        if (date.getYear() >= 2020 && date.getYear() <= 2022) {
            int weekNumber = date.get(WeekFields.of(Locale.getDefault()).weekOfWeekBasedYear());
            System.out.println("Неделя: " + weekNumber);
        } else {
            System.out.println("Дата должна быть в пределах 2020-2022 годов.");
        }
    }
}



11.	Разработайте программу, реализующую рекурсивное вычисление факториала.

public class Main {
    public static void main(String[] args) {
        int number = 5; // Можно заменить на любое число
        System.out.println(factorial(number));
    }

    public static long factorial(int n) {
        if (n == 0 || n == 1) return 1;
        return n * factorial(n - 1);
    }
}



12. Разработать класс-оболочку для числового типа double. Реализовать статические методы сложения, деления, возведения в степень.

public class DoubleWrapper {
    private double value;

    public DoubleWrapper(double value) {
        this.value = value;
    }

    public static double add(double a, double b) {
        return a + b;
    }

    public static double divide(double a, double b) {
        if (b == 0) throw new ArithmeticException("Division by zero");
        return a / b;
    }

    public static double power(double base, double exponent) {
        return Math.pow(base, exponent);
    }

    public double getValue() {
        return value;
    }

    public void setValue(double value) {
        this.value = value;
    }

    public static void main(String[] args) {
        System.out.println("Addition: " + DoubleWrapper.add(5.5, 4.5));
        System.out.println("Division: " + DoubleWrapper.divide(10.0, 2.0));
        System.out.println("Power: " + DoubleWrapper.power(2.0, 3.0));

        DoubleWrapper wrapper = new DoubleWrapper(10.0);
        System.out.println("Initial Value: " + wrapper.getValue());
        wrapper.setValue(20.0);
        System.out.println("Updated Value: " + wrapper.getValue());
    }
}
13. Разработать программу, которая заполняет двумерный массив случайными положительными числами в диапазоне от 1 до 100 до тех пор, пока сумма граничных элементов не станет равной 666. Пользователь вначале вводит размер матрицы. 
import java.util.Random;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();

        System.out.print("количество строк: ");
        int rows = scanner.nextInt();
        System.out.print("количество столбцов: ");
        int cols = scanner.nextInt();

        int[][] matrix = new int[rows][cols];

        int boundarySum = 0;

        while (boundarySum != 666) {
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    matrix[i][j] = random.nextInt(100) + 1; 
                }
            }

            boundarySum = 0;

            for (int j = 0; j < cols; j++) {
                boundarySum += matrix[0][j];
            }

            for (int j = 0; j < cols; j++) {
                boundarySum += matrix[rows - 1][j];
            }

            for (int i = 1; i < rows - 1; i++) {
                boundarySum += matrix[i][0];
            }

            for (int i = 1; i < rows - 1; i++) {
                boundarySum += matrix[i][cols - 1];
            }
        }

        System.out.println("Сгенерированная матрица:");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.print(matrix[i][j] + "\t");
            }
            System.out.println();
        }

    }
}
14. Разработать программу, в которой требуется создать класс, описывающий геометрическую фигуру – треугольник. Методами класса должны быть – вычисление площади, периметра. Создать класс-наследник, определяющий прямоугольный треугольник. 
// Базовый класс для треугольника
class Triangle {
    protected double a; 
    protected double b; 
    protected double c; 

  
    public Triangle(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public double getPerimeter() {
        return a + b + c;
    }

    public double getArea() {
        double s = getPerimeter() / 2; // Полупериметр
        return Math.sqrt(s * (s - a) * (s - b) * (s - c));
    }
}

class RightTriangle extends Triangle {
    // Конструктор
    public RightTriangle(double base, double height) {
        super(base, height, Math.sqrt(base * base + height * height)); 
    }

    @Override
    public double getArea() {
        return (a * b) / 2; 
    }
}

public class Main {
    public static void main(String[] args) {
     
        Triangle triangle = new Triangle(3, 4, 5);
        System.out.println("Треугольник:");
        System.out.println("Периметр: " + triangle.getPerimeter());
        System.out.println("Площадь: " + triangle.getArea());

        RightTriangle rightTriangle = new RightTriangle(3, 4);
        System.out.println("\nПрямоугольный треугольник:");
        System.out.println("Периметр: " + rightTriangle.getPerimeter());
        System.out.println("Площадь: " + rightTriangle.getArea());
    }
}

15. Разработать программу, в которой требуется создать абстрактный класс. В этом абстрактном классе определить абстрактные методы вычисления функции в определенной точке. Создать классы-наследники абстрактного класса, описывающими уравнения прямой и параболы. Программа должна выводить в консоль значение функции при вводе определенного значения.
import java.util.Scanner;

abstract class Function {
    public abstract double calculate(double x);
}

class Line extends Function {
    private double m;
    private double b; 

    public Line(double m, double b) {
        this.m = m;
        this.b = b;
    }

    @Override
    public double calculate(double x) {
        return m * x + b;
    }
}

class Parabola extends Function {
    private double a; // Коэффициент при x^2
    private double b; // Коэффициент при x
    private double c; // Свободный член

    
    public Parabola(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    
    @Override
    public double calculate(double x) {
        return a * x * x + b * x + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        
        Line line = new Line(2, 3); // y = 2x + 3
        System.out.print("Введите значение x для прямой: ");
        double xLine = scanner.nextDouble();
        System.out.println("Значение функции прямой: " + line.calculate(xLine));

        Parabola parabola = new Parabola(1, -2, 1); // y = x^2 - 2x + 1
        System.out.print("Введите значение x для параболы: ");
        double xParabola = scanner.nextDouble();
        System.out.println("Значение функции параболы: " + parabola.calculate(xParabola));
    }
}

 16. Создать интерфейс Progress c методами вычисления любого элемента прогрессии и суммы прогрессии. Разработать классы арифметической и геометрической прогрессии, которые имплементируют интерфейс Progress. 
interface Progress {
    double getElement(int n); 
    double getSum(int n);     
}

class ArithmeticProgression implements Progress {
    private double firstTerm; 
    private double difference; 

    public ArithmeticProgression(double firstTerm, double difference) {
        this.firstTerm = firstTerm;
        this.difference = difference;
    }

    @Override
    public double getElement(int n) {
        return firstTerm + (n - 1) * difference;
    }

    @Override
    public double getSum(int n) {
        return (n / 2.0) * (2 * firstTerm + (n - 1) * difference);
    }
}

class GeometricProgression implements Progress {
    private double firstTerm; 
    private double ratio;      

    public GeometricProgression(double firstTerm, double ratio) {
        this.firstTerm = firstTerm;
        this.ratio = ratio;
    }

    @Override
    public double getElement(int n) {
        return firstTerm * Math.pow(ratio, n - 1);
    }

    
    @Override
    public double getSum(int n) {
        if (ratio == 1) {
            return firstTerm * n; 
        }
        return firstTerm * (1 - Math.pow(ratio, n)) / (1 - ratio);
    }
}

public class Main {
    public static void main(String[] args) {
        ArithmeticProgression arithmeticProgression = new ArithmeticProgression(2, 3); 
        System.out.println("Арифметическая прогрессия:");
        System.out.println("5-й элемент: " + arithmeticProgression.getElement(5));
        System.out.println("Сумма первых 5 элементов: " + arithmeticProgression.getSum(5));

        
        GeometricProgression geometricProgression = new GeometricProgression(3, 2); 
        System.out.println("\nГеометрическая прогрессия:");
        System.out.println("5-й элемент: " + geometricProgression.getElement(5));
        System.out.println("Сумма первых 5 элементов: " + geometricProgression.getSum(5));
    }
}
17. Разработать интерфейс InArray, в котором предусмотреть метод сложения двух массивов. Создать класс ArraySum, в котором имплементируется метод сложения массивов. Создать класс OrArray, в котором метод сложения массивов имплементируется как логическая операция ИЛИ между элементами массива.
interface InArray {
    int[] addArrays(int[] array1, int[] array2); 
}

class ArraySum implements InArray {
    @Override
    public int[] addArrays(int[] array1, int[] array2) {
        int length = Math.min(array1.length, array2.length);
        int[] result = new int[length];

        for (int i = 0; i < length; i++) {
            result[i] = array1[i] + array2[i];
        }

        return result;
    }
}

class OrArray implements InArray {
    @Override
    public int[] addArrays(int[] array1, int[] array2) {
        int length = Math.min(array1.length, array2.length);
        int[] result = new int[length];

        for (int i = 0; i < length; i++) {
            result[i] = array1[i] | array2[i]; 
        }

        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        ArraySum arraySum = new ArraySum();
        int[] array1 = {1, 2, 3};
        int[] array2 = {4, 5, 6};
        int[] sumResult = arraySum.addArrays(array1, array2);
        System.out.println("Сумма массивов:");
        for (int value : sumResult) {
            System.out.print(value + " "); 
        }

        System.out.println();

        OrArray orArray = new OrArray();
        int[] orResult = orArray.addArrays(array1, array2);
        System.out.println("Результат  ИЛИ:");
        for (int value : orResult) {
            System.out.print(value + " "); // Ожидаемый результат: 5 7 7
        }
    }
}

 18. Создать класс Binary для работы с двоичными числами фиксированной длины. Число должно быть массивом тип char, каждый элемент которого принимает значение 0 или 1. Младший бит имеет младший индекс. Отрицательные числа представляются в дополнительном коде. Дополнительный код получается инверсией всех битов с прибавлением 1 к младшему биту. Например, +1 – это в двоичном коде будет выглядеть, как 0000 0001. А -1 в двоичном коде будет выглядеть, как 1111 1110 + 0000 0001 = 1111 1111. Создать методы конвертации десятичного числа в массив и обратно. 
public class Binary {
    private char[] binaryNumber; 
    private int length; 

    public Binary(int length) {
        this.length = length;
        this.binaryNumber = new char[length];
    }

    public void fromDecimal(int decimalNumber) {
        if (decimalNumber < 0) {
            decimalNumber = ~decimalNumber + 1;
        }

        
        for (int i = length - 1; i >= 0; i--) {
            binaryNumber[i] = (char) ((decimalNumber & 1) + '0');
            decimalNumber >>= 1;
        }
    }

    public int toDecimal() {
        int decimalNumber = 0;

        for (int i = 0; i < length; i++) {
            decimalNumber = (decimalNumber << 1) | (binaryNumber[i] - '0');
        }

        if ((binaryNumber[0] & 1) == 1) {
            decimalNumber = ~decimalNumber + 1;
        }

        return decimalNumber;
    }

    public void printBinary() {
        for (int i = 0; i < length; i++) {
            System.out.print(binaryNumber[i]);
        }
        System.out.println();
    }

    
    public static void main(String[] args) {
        Binary binary = new Binary(8); 

        binary.fromDecimal(10); 
        System.out.println("Двоичное представление  10:");
        binary.printBinary();

        int decimalNumber = binary.toDecimal(); 
        System.out.println("Десятичное представление : " + decimalNumber);

        binary.fromDecimal(-10); 
        System.out.println("Двоичное числа -10:");
        binary.printBinary();

        decimalNumber = binary.toDecimal(); 
        System.out.println("Десятичное представление числа: " + decimalNumber);
    }
}
19. Создать класс Matrix для работы с двумерными матрицами. Создать методы для генерации нулевой матрицы, а также для генерации матрицы со случайными величинами – применить Math.random(). Реализовать метод сложения матриц. 
import java.util.Random;

public class Matrix {
    private int[][] data; 
    private int rows;     
    private int cols;     


    public Matrix(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        this.data = new int[rows][cols];
    }


    public static Matrix zeroMatrix(int rows, int cols) {
        return new Matrix(rows, cols);
    }

    public static Matrix randomMatrix(int rows, int cols) {
        Matrix matrix = new Matrix(rows, cols);
        Random random = new Random();

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                matrix.data[i][j] = random.nextInt(100); 
            }
        }

        return matrix;
    }

    public Matrix add(Matrix other) {
        if (this.rows != other.rows || this.cols != other.cols) {
            throw new IllegalArgumentException("Матрицы должны иметь одинаковые размеры для сложения.");
        }

        Matrix result = new Matrix(this.rows, this.cols);
        for (int i = 0; i < this.rows; i++) {
            for (int j = 0; j < this.cols; j++) {
                result.data[i][j] = this.data[i][j] + other.data[i][j];
            }
        }

        return result;
    }

    
    public void printMatrix() {
        for (int[] row : data) {
            for (int value : row) {
                System.out.print(value + "\t");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Matrix zeroMatrix = Matrix.zeroMatrix(3, 3);
        System.out.println("Нулевая матрица:");
        zeroMatrix.printMatrix();

        Matrix randomMatrix1 = Matrix.randomMatrix(3, 3);
        System.out.println("\nСлучайная матрица 1:");
        randomMatrix1.printMatrix();

        Matrix randomMatrix2 = Matrix.randomMatrix(3, 3);
        System.out.println("\nСлучайная матрица 2:");
        randomMatrix2.printMatrix();

        Matrix sumMatrix = randomMatrix1.add(randomMatrix2);
        System.out.println("\nСумма матриц:");
        sumMatrix.printMatrix();
    }
}
20. Реализовать класс MyMath для работы с числами. Реализовать статический метод класса MyMath.round(), который округляет дробь до целого числа. Также статический метод abs(), который находит модуль числа. Статический метод MyMath.pow() для нахождения степени числа. Библиотеку Math не использовать. 
public class Main {
    public static int round(double number) {
        return (int) (number >= 0 ? number + 0.5 : number - 0.5);
    }

    public static double abs(double number) {
        return number >= 0 ? number : -number;
    }

    public static double pow(double base, int exponent) {
        double result = 1;
        for (int i = 0; i < abs(exponent); i++) {
            result *= base;
        }
        return exponent >= 0 ? result : 1 / result;
    }

    public static void main(String[] args) {
        System.out.println("Round 4.6: " + Main.round(4.6)); // 5
        System.out.println("Round -3.4: " + Main.round(-3.4)); // -3
        System.out.println("Absolute -5: " + Main.abs(-5)); // 5
        System.out.println("Absolute 7: " + Main.abs(7)); // 7
        System.out.println("Power 2^3: " + Main.pow(2, 3)); // 8.0
        System.out.println("Power 2^-3: " + Main.pow(2, -3)); // 0.125
    }
}21. Разработать программу для игры «Угадайка». Программа загадывает случайное число от 1 до 10, требуется его отгадать с трех попыток. После каждой попытки, если результат неверен, игроку выводится сообщение, меньше или больше названное игроком число, чем загаданное. Сет заканчивается или если игрок угадывает число, или если исчерпывает три попытки, не угадав. Игра должна быть выполнена в бесконечном цикле, и продолжается до тех пор, пока на предложение «Сыграем еще раз?» игрок не напишет «Нет».
import java.util.Scanner;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();
        boolean playAgain = true;

        while (playAgain) {
            int secretNumber = random.nextInt(10) + 1;
            System.out.println("Я загадал число от 1 до 10. У тебя три попытки угадать!");

            boolean guessed = false;
            for (int attempts = 1; attempts <= 3; attempts++) {
                System.out.print("Попытка " + attempts + ": ");
                int guess = scanner.nextInt();

                if (guess == secretNumber) {
                    System.out.println("Поздравляю! Ты угадал!");
                    guessed = true;
                    break;
                } else if (guess < secretNumber) {
                    System.out.println("Мое число больше.");
                } else {
                    System.out.println("Мое число меньше.");
                }
            }

            if (!guessed) {
                System.out.println("Ты не угадал. Загаданное число было: " + secretNumber);
            }

            System.out.print("Сыграем еще раз? (Да/Нет): ");
            String response = scanner.next();
            playAgain = response.equalsIgnoreCase("Да");
        }

        System.out.println("Спасибо за игру!");
    }
}
 22. Разработайте программу-генератор рабочего календаря. Слесарь механосборочного цеха работает сутки через трое. Если смена попадает на воскресенье, то переносится на понедельник. По введенной дате программа должна генерировать расписание из дат на текущий месяц на 2022 год. 
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите дату в формате ГГГГ-ММ-ДД: ");
        String inputDate = scanner.nextLine();
        LocalDate startDate = LocalDate.parse(inputDate, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        int year = 2022;
        LocalDate currentDate = LocalDate.of(year, startDate.getMonthValue(), 1);

        System.out.println("Рабочий график на " + currentDate.getMonth() + " " + year + ":");
        while (currentDate.getMonthValue() == startDate.getMonthValue()) {
            if (isWorkDay(startDate, currentDate)) {
                System.out.println(currentDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd")));
            }
            currentDate = currentDate.plusDays(1);
        }
    }

    private static boolean isWorkDay(LocalDate startDate, LocalDate currentDate) {
        long daysBetween = java.time.temporal.ChronoUnit.DAYS.between(startDate, currentDate);
        if (daysBetween % 4 == 0) {
            if (currentDate.getDayOfWeek().getValue() == 7) {
                return false;
            }
            if (currentDate.getDayOfWeek().getValue() == 1) return true;
            return false;
        }
        return true;
    }
}
23. Разработать класс для представления комплексных чисел с возможностью задания вещественной и мнимой частей в виде массива из двух чисел типа int. Определить методы для выполнения операций сложения, вычитания и умножения комплексных чисел.
public class ComplexNumber {
    private int real;
    private int imaginary;

    public ComplexNumber(int real, int imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    public ComplexNumber(int[] parts) {
        this.real = parts[0];
        this.imaginary = parts[1];
    }

    public ComplexNumber add(ComplexNumber other) {
        return new ComplexNumber(this.real + other.real, this.imaginary + other.imaginary);
    }

    public ComplexNumber subtract(ComplexNumber other) {
        return new ComplexNumber(this.real - other.real, this.imaginary - other.imaginary);
    }

    public ComplexNumber multiply(ComplexNumber other) {
        int realPart = this.real * other.real - this.imaginary * other.imaginary;
        int imaginaryPart = this.real * other.imaginary + this.imaginary * other.real;
        return new ComplexNumber(realPart, imaginaryPart);
    }

    @Override
    public String toString() {
        return real + (imaginary >= 0 ? " + " : " - ") + Math.abs(imaginary) + "i";
    }

    public static void main(String[] args) {
        ComplexNumber num1 = new ComplexNumber(3, 4);
        ComplexNumber num2 = new ComplexNumber(new int[]{1, -2});

        System.out.println("Число 1: " + num1);
        System.out.println("Число 2: " + num2);

        System.out.println("Сумма: " + num1.add(num2));
        System.out.println("Разность: " + num1.subtract(num2));
        System.out.println("Произведение: " + num1.multiply(num2));
    }
} 24. Создайте класс Form - оболочку для создания и ввода пароля. Он должен иметь методы input, submit, password. Создайте класс SmartForm, который будет наследовать от Form и сохранять значения password.
import java.util.Scanner;

class Form {
    private String password;

    public void input() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите пароль: ");
        password = scanner.nextLine();
    }

    public void submit() {
        if (password != null && !password.isEmpty()) {
            System.out.println("Пароль успешно отправлен.");
        } else {
            System.out.println("Пароль не может быть пустым.");
        }
    }

    public String password() {
        return password;
    }
}

class SmartForm extends Form {
    private String savedPassword;

    @Override
    public void submit() {
        super.submit();
        savedPassword = password();
    }

    public String getSavedPassword() {
        return savedPassword;
    }
}

public class Main {
    public static void main(String[] args) {
        SmartForm smartForm = new SmartForm();

        smartForm.input();
        smartForm.submit();
        System.out.println("Сохраненный пароль: " + smartForm.getSavedPassword());
    }
}

25. Сделайте класс User, в котором будут следующие protected поля - name (имя), age (возраст), public методы setName, getName, setAge, getAge. Сделайте класс Worker, который наследует от класса User и вносит дополнительное private поле salary (зарплата), а также методы public getSalary и setSalary. Создайте объект этого класса 'Иван', возраст 25, зарплата 1000. Создайте второй объект этого класса 'Вася', возраст 26, зарплата 2000. Найдите сумму зарплата Ивана и Васи. Сделайте класс Student, который наследует от класса User и вносит дополнительные private поля стипендия, курс, а также геттеры и сеттеры для них.
1. User.java
java
КопироватьРедактировать
public class User {
    protected String name;
    protected int age;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}

2. Worker.java
java
КопироватьРедактировать
public class Worker extends User {
    private int salary;

    public void setSalary(int salary) {
        this.salary = salary;
    }

    public int getSalary() {
        return salary;
    }
}

3. Student.java
java
КопироватьРедактировать
public class Student extends User {
    private double scholarship;
    private int course;

    public void setScholarship(double scholarship) {
        this.scholarship = scholarship;
    }

    public double getScholarship() {
        return scholarship;
    }

    public void setCourse(int course) {
        this.course = course;
    }

    public int getCourse() {
        return course;
    }
}

4. Main.java
java
КопироватьРедактировать
public class Main {
    public static void main(String[] args) {
        // Создание объектов Worker
        Worker ivan = new Worker();
        ivan.setName("Иван");
        ivan.setAge(25);
        ivan.setSalary(1000);

        Worker vasya = new Worker();
        vasya.setName("Вася");
        vasya.setAge(26);
        vasya.setSalary(2000);

        // Сумма зарплат
        int totalSalary = ivan.getSalary() + vasya.getSalary();
        System.out.println("Сумма зарплат Ивана и Васи: " + totalSalary);

        // Создание объекта Student
        Student student = new Student();
        student.setName("Алексей");
        student.setAge(20);
        student.setScholarship(500.5);
        student.setCourse(3);

        // Вывод информации о студенте
        System.out.println("Студент: " + student.getName());
        System.out.println("Возраст: " + student.getAge());
        System.out.println("Стипендия: " + student.getScholarship());
        System.out.println("Курс: " + student.getCourse());
    }
}

26. Создайте класс ColorModel для определения цветовой модели. Разработайте подклассы RGBconverter и CMYKconverter для конвертации цвета из одной модели в другую. Конвертация CMYK в RGB производится по следующим формулам: R = 255 × (1-C) × (1-K), G = 255 × (1-M) × (1-K), B = 255 × (1-Y) × (1-K) (где R – red, G – green, B – black, C – Cyan, M - Magenta, Y - Yellow, K- Black))
1. ColorModel.java
java
КопироватьРедактировать
public class ColorModel {
    private String modelName;

    public ColorModel(String modelName) {
        this.modelName = modelName;
    }

    public String getModelName() {
        return modelName;
    }

    public void setModelName(String modelName) {
        this.modelName = modelName;
    }
}
2. RGBconverter.java
java
КопироватьРедактировать
public class RGBconverter extends ColorModel {
    private int red;
    private int green;
    private int blue;

    public RGBconverter(int red, int green, int blue) {
        super("RGB");
        this.red = validateColorValue(red);
        this.green = validateColorValue(green);
        this.blue = validateColorValue(blue);
    }

    private int validateColorValue(int value) {
        if (value < 0 || value > 255) {
            throw new IllegalArgumentException("Цветовое значение должно быть в диапазоне от 0 до 255.");
        }
        return value;
    }

    public int getRed() {
        return red;
    }

    public int getGreen() {
        return green;
    }

    public int getBlue() {
        return blue;
    }

    @Override
    public String toString() {
        return "RGB(" + red + ", " + green + ", " + blue + ")";
    }
}
3. CMYKconverter.java
java
КопироватьРедактировать
public class CMYKconverter extends ColorModel {
    private double cyan;
    private double magenta;
    private double yellow;
    private double black;

    public CMYKconverter(double cyan, double magenta, double yellow, double black) {
        super("CMYK");
        this.cyan = validatePercentage(cyan);
        this.magenta = validatePercentage(magenta);
        this.yellow = validatePercentage(yellow);
        this.black = validatePercentage(black);
    }

    private double validatePercentage(double value) {
        if (value < 0.0 || value > 1.0) {
            throw new IllegalArgumentException("Значение должно быть в диапазоне от 0.0 до 1.0.");
        }
        return value;
    }

    public RGBconverter toRGB() {
        int red = (int) (255 * (1 - cyan) * (1 - black));
        int green = (int) (255 * (1 - magenta) * (1 - black));
        int blue = (int) (255 * (1 - yellow) * (1 - black));

        return new RGBconverter(red, green, blue);
    }

    @Override
    public String toString() {
        return "CMYK(" + cyan + ", " + magenta + ", " + yellow + ", " + black + ")";
    }
}
4. Main.java
java
КопироватьРедактировать
public class Main {
    public static void main(String[] args) {
        // Создаем объект CMYK
        CMYKconverter cmykColor = new CMYKconverter(0.5, 0.4, 0.3, 0.2);
        System.out.println("CMYK цвет: " + cmykColor);

        // Конвертация CMYK в RGB
        RGBconverter rgbColor = cmykColor.toRGB();
        System.out.println("Преобразованный RGB цвет: " + rgbColor);

        // Пример RGB цвета
        RGBconverter anotherRgbColor = new RGBconverter(128, 64, 255);
        System.out.println("Другой RGB цвет: " + anotherRgbColor);
    }
}



27. Создайте класс Number для конвертации десятичного числа в бинарный, восьмеричный, шестнадцатеричный вид. Реализовать в виде статических методов класса. Числа вводятся с клавиатуры с запросом в какой численный вид конвертировать.
Number.java
java
КопироватьРедактировать
import java.util.Scanner;

public class Number {
    // Метод для преобразования числа в бинарный формат
    public static String toBinary(int number) {
        return Integer.toBinaryString(number);
    }

    // Метод для преобразования числа в восьмеричный формат
    public static String toOctal(int number) {
        return Integer.toOctalString(number);
    }

    // Метод для преобразования числа в шестнадцатеричный формат
    public static String toHexadecimal(int number) {
        return Integer.toHexString(number).toUpperCase(); // Преобразуем в верхний регистр для читаемости
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Запрос числа у пользователя
        System.out.print("Введите число: ");
        int number = scanner.nextInt();

        // Запрос выбора формата конверсии
        System.out.println("Выберите формат конверсии:");
        System.out.println("1 - Бинарный");
        System.out.println("2 - Восьмеричный");
        System.out.println("3 - Шестнадцатеричный");
        System.out.print("Введите номер формата: ");
        int choice = scanner.nextInt();

        // Выполнение конверсии на основе выбора пользователя
        switch (choice) {
            case 1:
                System.out.println("Бинарный формат: " + toBinary(number));
                break;
            case 2:
                System.out.println("Восьмеричный формат: " + toOctal(number));
                break;
            case 3:
                System.out.println("Шестнадцатеричный формат: " + toHexadecimal(number));
                break;
            default:
                System.out.println("Неверный выбор!");
        }

        scanner.close();
    }
}

28. Разработать класс Neuron для реализации нейронной сети из двух нейронов и одного выхода. Сделать функцию прямого распространения с функцией активации в виде сигмоиды.
Neuron.java
java
КопироватьРедактировать
public class Neuron {
    private double[] weights; // Весовые коэффициенты
    private double bias;      // Смещение

    // Конструктор для инициализации весов и смещения
    public Neuron(double[] weights, double bias) {
        this.weights = weights;
        this.bias = bias;
    }

    // Метод для прямого распространения (вычисление выхода нейрона)
    public double forward(double[] inputs) {
        if (inputs.length != weights.length) {
            throw new IllegalArgumentException("Количество входов должно совпадать с количеством весов.");
        }

        double sum = 0.0;
        for (int i = 0; i < inputs.length; i++) {
            sum += inputs[i] * weights[i]; // Взвешенная сумма
        }
        sum += bias; // Добавляем смещение
        return sigmoid(sum); // Применяем сигмоидную функцию активации
    }

    // Сигмоидная функция активации
    private double sigmoid(double x) {
        return 1 / (1 + Math.exp(-x));
    }

    public static void main(String[] args) {
        // Создаем два нейрона
        Neuron neuron1 = new Neuron(new double[]{0.5, 0.8}, 0.1); // Веса и смещение
        Neuron neuron2 = new Neuron(new double[]{0.3, 0.2}, -0.2);

        // Создаем выходной нейрон
        Neuron outputNeuron = new Neuron(new double[]{0.9, 0.7}, 0.0);

        // Входные данные
        double[] inputs = {1.0, 0.5};

        // Прямое распространение для первого слоя
        double output1 = neuron1.forward(inputs);
        double output2 = neuron2.forward(inputs);

        // Входы для выходного нейрона
        double[] hiddenLayerOutputs = {output1, output2};

        // Прямое распространение для выходного слоя
        double finalOutput = outputNeuron.forward(hiddenLayerOutputs);

        // Вывод результата
        System.out.println("Выход первого нейрона: " + output1);
        System.out.println("Выход второго нейрона: " + output2);
        System.out.println("Итоговый выход: " + finalOutput);
    }
}

29. Напишите программу, которая заполняет списочный массив случайными числами типа Integer (значения этих чисел были от 1 до 100). Список должен содержать 100 элементов. Затем отсортируйте по убыванию список и выведите первые 10 значений в консоль. Результатыы сохраните в MySQL/PostgreSQL.
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public class RandomListSort {
    public static void main(String[] args) {
        // Шаг 1: Создаем и заполняем список случайными числами
        List<Integer> numbers = new ArrayList<>();
        Random random = new Random();

        for (int i = 0; i < 100; i++) {
            numbers.add(random.nextInt(100) + 1); // Числа от 1 до 100
        }

        // Шаг 2: Сортировка списка в порядке убывания
        numbers.sort(Collections.reverseOrder());

        // Вывод первых 10 значений
        System.out.println("Первые 10 значений (по убыванию):");
        List<Integer> top10Numbers = numbers.subList(0, 10);
        top10Numbers.forEach(System.out::println);

        // Шаг 3: Сохранение результатов в PostgreSQL
        saveToDatabase(top10Numbers);
    }

    // Метод для сохранения списка в базу данных
    private static void saveToDatabase(List<Integer> numbers) {
        String url = "jdbc:postgresql://localhost:5432/your_database_name"; // Замените на ваше имя базы
        String user = "your_username"; // Замените на ваше имя пользователя
        String password = "your_password"; // Замените на ваш пароль

        String insertQuery = "INSERT INTO top_numbers (number) VALUES (?)";

        try (Connection connection = DriverManager.getConnection(url, user, password);
             PreparedStatement preparedStatement = connection.prepareStatement(insertQuery)) {

            // Вставляем каждое число в таблицу
            for (Integer number : numbers) {
                preparedStatement.setInt(1, number);
                preparedStatement.executeUpdate();
            }

            System.out.println("Результаты успешно сохранены в базу данных.");
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
        }
    }
}
SQL
CREATE TABLE top_numbers ( id SERIAL PRIMARY KEY, number INTEGER NOT NULL );
30. Разработайте программу, которая заполняет список случайными числами. Количество элементов и числовой диапазон вводятся пользователем. Программа должна проверять, входит ли число (также вводится пользователем) в данный список. Должен быть реализован бинарный поиск. Результаты должны сохраняться в MySQL/PostgreSQL и выводиться оттуда же.
BinarySearchProgram.java
import java.sql.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

public class BinarySearchProgram {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Шаг 1: Ввод данных пользователем
        System.out.print("Введите количество элементов: ");
        int size = scanner.nextInt();

        System.out.print("Введите минимальное значение диапазона: ");
        int min = scanner.nextInt();

        System.out.print("Введите максимальное значение диапазона: ");
        int max = scanner.nextInt();

        System.out.print("Введите число для поиска: ");
        int target = scanner.nextInt();

        // Шаг 2: Генерация списка случайных чисел
        List<Integer> numbers = generateRandomList(size, min, max);

        // Сортировка списка для бинарного поиска
        Collections.sort(numbers);
        System.out.println("Сгенерированный список (отсортированный): " + numbers);

        // Шаг 3: Реализация бинарного поиска
        boolean isFound = binarySearch(numbers, target);
        System.out.println("Число " + target + (isFound ? " найдено." : " не найдено."));

        // Шаг 4: Сохранение данных в PostgreSQL
        saveToDatabase(numbers, target, isFound);

        // Шаг 5: Вывод данных из базы
        retrieveFromDatabase();

        scanner.close();
    }

    // Генерация случайного списка
    private static List<Integer> generateRandomList(int size, int min, int max) {
        List<Integer> numbers = new ArrayList<>();
        Random random = new Random();

        for (int i = 0; i < size; i++) {
            numbers.add(random.nextInt(max - min + 1) + min); // Число в диапазоне [min, max]
        }

        return numbers;
    }

    // Реализация бинарного поиска
    private static boolean binarySearch(List<Integer> list, int target) {
        int left = 0, right = list.size() - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (list.get(mid) == target) {
                return true;
            } else if (list.get(mid) < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }

    // Сохранение данных в PostgreSQL
    private static void saveToDatabase(List<Integer> numbers, int target, boolean isFound) {
        String url = "jdbc:postgresql://localhost:5432/your_database_name"; // Замените на ваше имя базы
        String user = "your_username"; // Замените на ваше имя пользователя
        String password = "your_password"; // Замените на ваш пароль

        String insertQuery = "INSERT INTO search_results (list, target, result) VALUES (?, ?, ?)";

        try (Connection connection = DriverManager.getConnection(url, user, password);
             PreparedStatement preparedStatement = connection.prepareStatement(insertQuery)) {

            // Преобразуем список в строку
            String listAsString = numbers.toString();

            // Устанавливаем параметры запроса
            preparedStatement.setString(1, listAsString);
            preparedStatement.setInt(2, target);
            preparedStatement.setBoolean(3, isFound);

            // Выполняем вставку
            preparedStatement.executeUpdate();
            System.out.println("Результаты успешно сохранены в базу данных.");
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
        }
    }

    // Вывод данных из базы
    private static void retrieveFromDatabase() {
        String url = "jdbc:postgresql://localhost:5432/your_database_name"; // Замените на ваше имя базы
        String user = "your_username"; // Замените на ваше имя пользователя
        String password = "your_password"; // Замените на ваш пароль

        String selectQuery = "SELECT * FROM search_results";

        try (Connection connection = DriverManager.getConnection(url, user, password);
             Statement statement = connection.createStatement();
             ResultSet resultSet = statement.executeQuery(selectQuery)) {

            System.out.println("Результаты из базы данных:");
            while (resultSet.next()) {
                String list = resultSet.getString("list");
                int target = resultSet.getInt("target");
                boolean result = resultSet.getBoolean("result");

                System.out.printf("Список: %s, Число для поиска: %d, Найдено: %b%n", list, target, result);
            }
        } catch (SQLException e) {
            System.err.println("Ошибка чтения из базы данных: " + e.getMessage());
        }
    }
}
SQL
CREATE TABLE search_results (
    id SERIAL PRIMARY KEY,
    list TEXT NOT NULL,
    target INTEGER NOT NULL,
    result BOOLEAN NOT NULL
);
31. На основе класса BitSet разработайте программу для реализации битовых операций AND, OR, XOR, а также маскирования.
BitSetOperations.java
import java.util.BitSet;

public class BitSetOperations {
    public static void main(String[] args) {
        // Создаем два объекта BitSet с размером 8 (для примера)
        BitSet bitSet1 = new BitSet(8);
        BitSet bitSet2 = new BitSet(8);

        // Устанавливаем произвольные биты для bitSet1
        bitSet1.set(0);
        bitSet1.set(2);
        bitSet1.set(4);
        bitSet1.set(6);

        // Устанавливаем произвольные биты для bitSet2
        bitSet2.set(1);
        bitSet2.set(2);
        bitSet2.set(5);
        bitSet2.set(6);

        // Выводим начальные значения
        System.out.println("BitSet1: " + bitSet1);
        System.out.println("BitSet2: " + bitSet2);

        // Операция AND (логическое И)
        BitSet andResult = (BitSet) bitSet1.clone();
        andResult.and(bitSet2);
        System.out.println("Результат AND (логическое И): " + andResult);

        // Операция OR (логическое ИЛИ)
        BitSet orResult = (BitSet) bitSet1.clone();
        orResult.or(bitSet2);
        System.out.println("Результат OR (логическое ИЛИ): " + orResult);

        // Операция XOR (логическое исключающее ИЛИ)
        BitSet xorResult = (BitSet) bitSet1.clone();
        xorResult.xor(bitSet2);
        System.out.println("Результат XOR (логическое исключающее ИЛИ): " + xorResult);

        // Маскирование (сбрасываем все биты, кроме указанных)
        BitSet mask = new BitSet(8);
        mask.set(2);
        mask.set(4);
        mask.set(6);

        BitSet maskedResult = (BitSet) bitSet1.clone();
        maskedResult.and(mask);
        System.out.println("Результат маскирования: " + maskedResult);
    }
}
32. Напишите программу, которая получает в качестве входных данных два числа. Эти числа являются количество строк и столбцов двумерной коллекции целых чисел. Далее элементы заполняются случайными числами и выводятся в консоль в виде таблицы.
TwoDimensionalArray.java
import java.util.Random;
import java.util.Scanner;

public class TwoDimensionalArray {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();

        // Шаг 1: Ввод данных пользователем
        System.out.print("Введите количество строк: ");
        int rows = scanner.nextInt();

        System.out.print("Введите количество столбцов: ");
        int cols = scanner.nextInt();

        // Проверка на корректность ввода
        if (rows <= 0 || cols <= 0) {
            System.out.println("Количество строк и столбцов должно быть больше нуля.");
            return;
        }

        // Шаг 2: Создание и заполнение двумерного массива
        int[][] array = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                array[i][j] = random.nextInt(100); // Случайные числа от 0 до 99
            }
        }

        // Шаг 3: Вывод массива в виде таблицы
        System.out.println("Сгенерированная таблица:");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.printf("%4d", array[i][j]); // Форматированный вывод
            }
            System.out.println();
        }

        scanner.close();
    }
}
33. Разработайте программу, которая получает в качестве параметра два числа –количество строк и столбцов двумерной коллекции целых чисел. Коллекция заполняется случайными числами, после чего на экран выводятся максимальное и минимальное значения с индексами ячеек.
TwoDimensionalCollectionMinMax.java
import java.util.Random;
import java.util.Scanner;

public class TwoDimensionalCollectionMinMax {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();

        // Шаг 1: Ввод данных пользователя
        System.out.print("Введите количество строк: ");
        int rows = scanner.nextInt();

        System.out.print("Введите количество столбцов: ");
        int cols = scanner.nextInt();

        // Проверка на корректность ввода
        if (rows <= 0 || cols <= 0) {
            System.out.println("Количество строк и столбцов должно быть больше нуля.");
            return;
        }

        // Шаг 2: Создание двумерной коллекции
        int[][] array = new int[rows][cols];

        // Шаг 3: Заполнение коллекции случайными числами и поиск мин/макс значений
        int maxValue = Integer.MIN_VALUE;
        int minValue = Integer.MAX_VALUE;
        int maxRow = -1, maxCol = -1;
        int minRow = -1, minCol = -1;

        System.out.println("Сгенерированная таблица:");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                array[i][j] = random.nextInt(100); // Случайные числа от 0 до 99
                System.out.printf("%4d", array[i][j]); // Форматированный вывод

                // Обновление максимального значения
                if (array[i][j] > maxValue) {
                    maxValue = array[i][j];
                    maxRow = i;
                    maxCol = j;
                }

                // Обновление минимального значения
                if (array[i][j] < minValue) {
                    minValue = array[i][j];
                    minRow = i;
                    minCol = j;
                }
            }
            System.out.println();
        }

        // Шаг 4: Вывод результатов
        System.out.println("\nРезультаты:");
        System.out.printf("Максимальное значение: %d (индексы: [%d][%d])\n", maxValue, maxRow, maxCol);
        System.out.printf("Минимальное значение: %d (индексы: [%d][%d])\n", minValue, minRow, minCol);

        scanner.close();
    }
}
34. Разработайте программу, в которой создайте две коллекции с именами людей (строковые переменные). Результат сохранить в MySQL/PostgreSQL. Затем последовательно выводите в консоль имена.
NamesCollectionApp.java
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class NamesCollectionApp {
    private static final String DB_URL = "jdbc:postgresql://localhost:5432/your_database"; // Замените на вашу БД
    private static final String DB_USER = "your_username"; // Замените на ваше имя пользователя
    private static final String DB_PASSWORD = "your_password"; // Замените на ваш пароль

    public static void main(String[] args) {
        // Шаг 1: Создание двух коллекций с именами
        List<String> collection1 = new ArrayList<>();
        List<String> collection2 = new ArrayList<>();

        collection1.add("Иван");
        collection1.add("Петр");
        collection1.add("Сергей");

        collection2.add("Анна");
        collection2.add("Мария");
        collection2.add("Елена");

        // Шаг 2: Сохранение данных в PostgreSQL
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {
            // Создаем таблицу для хранения имен, если она не существует
            String createTableSQL = """
                CREATE TABLE IF NOT EXISTS names (
                    id SERIAL PRIMARY KEY,
                    name VARCHAR(50) NOT NULL
                )
            """;
            try (Statement statement = connection.createStatement()) {
                statement.executeUpdate(createTableSQL);
            }

            // Очищаем таблицу перед добавлением новых данных
            try (Statement statement = connection.createStatement()) {
                statement.executeUpdate("DELETE FROM names");
            }

            // Добавляем имена из коллекций в таблицу
            String insertSQL = "INSERT INTO names (name) VALUES (?)";
            try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
                for (String name : collection1) {
                    preparedStatement.setString(1, name);
                    preparedStatement.executeUpdate();
                }
                for (String name : collection2) {
                    preparedStatement.setString(1, name);
                    preparedStatement.executeUpdate();
                }
            }

            System.out.println("Имена успешно сохранены в базу данных.");
        } catch (SQLException e) {
            System.out.println("Ошибка при работе с базой данных: " + e.getMessage());
        }

        // Шаг 3: Извлечение данных из базы данных и вывод в консоль
        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {
            String selectSQL = "SELECT name FROM names";
            try (Statement statement = connection.createStatement();
                 ResultSet resultSet = statement.executeQuery(selectSQL)) {
                System.out.println("Список имен из базы данных:");
                while (resultSet.next()) {
                    String name = resultSet.getString("name");
                    System.out.println(name);
                }
            }
        } catch (SQLException e) {
            System.out.println("Ошибка при извлечении данных из базы данных: " + e.getMessage());
        }
    }
}
35. Напишите программу, которая реализует класс Matrix и следующие методы:
a. Сложение и вычитание матриц.
b. Умножение матрицы на число.
c. Произведение двух матриц.
d. Транспонированная матрица.
e. Возведение матрицы в степень.
f. Если метод, возвращает матрицу, то он должен возвращать новый объект, а не менять базовый.

Matrix.java
import java.util.Arrays;

public class Matrix {
    private final int rows;
    private final int cols;
    private final double[][] data;

    // Конструктор
    public Matrix(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        this.data = new double[rows][cols];
    }

    // Конструктор с данными
    public Matrix(double[][] data) {
        this.rows = data.length;
        this.cols = data[0].length;
        this.data = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            System.arraycopy(data[i], 0, this.data[i], 0, cols);
        }
    }

    // Получение строк и столбцов
    public int getRows() {
        return rows;
    }

    public int getCols() {
        return cols;
    }

    // Метод для сложения матриц
    public Matrix add(Matrix other) {
        if (this.rows != other.rows || this.cols != other.cols) {
            throw new IllegalArgumentException("Размеры матриц должны совпадать для сложения.");
        }
        double[][] result = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[i][j] = this.data[i][j] + other.data[i][j];
            }
        }
        return new Matrix(result);
    }

    // Метод для вычитания матриц
    public Matrix subtract(Matrix other) {
        if (this.rows != other.rows || this.cols != other.cols) {
            throw new IllegalArgumentException("Размеры матриц должны совпадать для вычитания.");
        }
        double[][] result = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[i][j] = this.data[i][j] - other.data[i][j];
            }
        }
        return new Matrix(result);
    }

    // Метод для умножения матрицы на число
    public Matrix multiplyByNumber(double number) {
        double[][] result = new double[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[i][j] = this.data[i][j] * number;
            }
        }
        return new Matrix(result);
    }

    // Метод для произведения двух матриц
    public Matrix multiply(Matrix other) {
        if (this.cols != other.rows) {
            throw new IllegalArgumentException("Число столбцов первой матрицы должно совпадать с числом строк второй матрицы.");
        }
        double[][] result = new double[this.rows][other.cols];
        for (int i = 0; i < this.rows; i++) {
            for (int j = 0; j < other.cols; j++) {
                for (int k = 0; k < this.cols; k++) {
                    result[i][j] += this.data[i][k] * other.data[k][j];
                }
            }
        }
        return new Matrix(result);
    }

    // Метод для транспонирования матрицы
    public Matrix transpose() {
        double[][] result = new double[cols][rows];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[j][i] = this.data[i][j];
            }
        }
        return new Matrix(result);
    }

    // Метод для возведения матрицы в степень
    public Matrix power(int exponent) {
        if (rows != cols) {
            throw new IllegalArgumentException("Матрица должна быть квадратной для возведения в степень.");
        }
        Matrix result = new Matrix(this.data);
        for (int i = 1; i < exponent; i++) {
            result = result.multiply(this);
        }
        return result;
    }

    // Печать матрицы
    public void printMatrix() {
        for (double[] row : data) {
            System.out.println(Arrays.toString(row));
        }
    }

    // Главный метод для тестирования
    public static void main(String[] args) {
        double[][] data1 = {
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
        };

        double[][] data2 = {
                {9, 8, 7},
                {6, 5, 4},
                {3, 2, 1}
        };

        Matrix matrix1 = new Matrix(data1);
        Matrix matrix2 = new Matrix(data2);

        System.out.println("Сложение матриц:");
        Matrix sum = matrix1.add(matrix2);
        sum.printMatrix();

        System.out.println("\nВычитание матриц:");
        Matrix diff = matrix1.subtract(matrix2);
        diff.printMatrix();

        System.out.println("\nУмножение матрицы на число (2):");
        Matrix scaled = matrix1.multiplyByNumber(2);
        scaled.printMatrix();

        System.out.println("\nПроизведение матриц:");
        Matrix product = matrix1.multiply(matrix2);
        product.printMatrix();

        System.out.println("\nТранспонированная матрица:");
        Matrix transposed = matrix1.transpose();
        transposed.printMatrix();

        System.out.println("\nМатрица в квадрате:");
        Matrix squared = matrix1.power(2);
        squared.printMatrix();
    }
}
36. Разработать программу для поочередной обработки текстовых файлов. Файлы созданы со следующими именами: n.txt, где n – натуральное число. В файлах записаны: в первой строке одно число с плавающей запятой, во второй строке – второе число. Пользователь вводит название файла и требуемую операцию над числами (сложение, умножение, разность). Результат выводится на экран и файл n_out.txt. 
package org.example;

import java.io.*;
import java.util.Scanner;

public class FileProcessor {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Запрос имени файла
        System.out.print("Введите имя файла (например, 1.txt): ");
        String fileName = scanner.nextLine();

        // Запрос операции
        System.out.print("Введите операцию (сложение, вычитание, умножение): ");
        String operation = scanner.nextLine().toLowerCase();

        try {
            // Чтение чисел из файла
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            double firstNumber = Double.parseDouble(reader.readLine());
            double secondNumber = Double.parseDouble(reader.readLine());
            reader.close();

            double result = 0;
            switch (operation) {
                case "сложение":
                    result = firstNumber + secondNumber;
                    break;
                case "вычитание":
                    result = firstNumber - secondNumber;
                    break;
                case "умножение":
                    result = firstNumber * secondNumber;
                    break;
                default:
                    System.out.println("Неизвестная операция.");
                    return;
            }

            // Вывод результата на экран
            System.out.println("Результат: " + result);

            // Запись результата в файл n_out.txt
            String outputFileName = fileName.replace(".txt", "_out.txt");
            BufferedWriter writer = new BufferedWriter(new FileWriter(outputFileName));
            writer.write("Результат: " + result);
            writer.close();

            System.out.println("Результат записан в файл: " + outputFileName);

        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден: " + fileName);
        } catch (IOException e) {
            System.out.println("Ошибка при чтении/записи файла.");
        } catch (NumberFormatException e) {
            System.out.println("Ошибка формата числа в файле.");
        }
    }
}

37. Написать приложение для сложения, вычитания, умножения, деления, возведения в степень логарифмов. Программа должна выполнять ввод данных, проверку правильности введенных данных, выдачу сообщений в случае ошибок. Результат выводится на экран и записывается в файл. 
package org.example;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.InputMismatchException;
import java.util.Scanner;

public class LogCalculator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double base = 0;
        double value1 = 0;
        double value2 = 0;
        String operation = "";

        try {
            System.out.print("Введите основание логарифма (больше 0 и не равно 1): ");
            base = scanner.nextDouble();
            if (base <= 0 || base == 1) {
                throw new IllegalArgumentException("Основание должно быть больше 0 и не равно 1.");
            }

            System.out.print("Введите первое значение: ");
            value1 = scanner.nextDouble();
            System.out.print("Введите второе значение: ");
            value2 = scanner.nextDouble();

            System.out.print("Введите операцию (+, -, *, /, ^): ");
            operation = scanner.next();

            double result = 0;
            switch (operation) {
                case "+":
                    result = Math.log(value1) / Math.log(base) + Math.log(value2) / Math.log(base);
                    break;
                case "-":
                    result = Math.log(value1) / Math.log(base) - Math.log(value2) / Math.log(base);
                    break;
                case "*":
                    result = Math.log(value1) / Math.log(base) * Math.log(value2) / Math.log(base);
                    break;
                case "/":
                    if (value2 == 0) {
                        throw new ArithmeticException("Деление на ноль невозможно.");
                    }
                    result = Math.log(value1) / Math.log(base) / (Math.log(value2) / Math.log(base));
                    break;
                case "^":
                    result = Math.pow(Math.log(value1) / Math.log(base), value2);
                    break;
                default:
                    throw new IllegalArgumentException("Неверная операция.");
            }

            System.out.printf("Результат: %.4f%n", result);
            writeResultToFile(result);

        } catch (InputMismatchException e) {
            System.out.println("Ошибка ввода: введите числовое значение.");
        } catch (IllegalArgumentException | ArithmeticException e) {
            System.out.println("Ошибка: " + e.getMessage());
        } finally {
            scanner.close();
        }
    }

    private static void writeResultToFile(double result) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("result.txt", true))) {
            writer.write("Результат: " + result);
            writer.newLine();
        } catch (IOException e) {
            System.out.println("Ошибка записи в файл: " + e.getMessage());
        }
    }
}

// 

38.Разработать программу шифровки-дешифровки по алгоритму AES-128. Данные берутся из файла, зашифрованные данные сохраняются в указанный файл. 
package org.example;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.SecureRandom;

public class AESCipher {

    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";
    private static final int KEY_SIZE = 128; // AES-128

    public static void main(String[] args) {
        String keyFilePath = "secret_key.txt"; // Путь к файлу с ключом
        String inputFilePath = "/Users/daniilgornatenko/Desktop/EX_38/src/main/java/org/example/input.txt"; // Путь к входному файлу
        String encryptedFilePath = "encrypted.txt"; // Путь к выходному файлу с зашифрованными данными
        String decryptedFilePath = "decrypted.txt"; // Путь к выходному файлу с расшифрованными данными

        try {
            // Генерация ключа и сохранение его в файл
            SecretKey secretKey = generateKey();
            saveKey(secretKey, keyFilePath);

            // Шифрование данных
            encrypt(inputFilePath, encryptedFilePath, secretKey);

            // Дешифрование данных
            decrypt(encryptedFilePath, decryptedFilePath, secretKey);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static SecretKey generateKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);
        keyGen.init(KEY_SIZE);
        return keyGen.generateKey();
    }

    private static void saveKey(SecretKey key, String filePath) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(filePath)) {
            fos.write(key.getEncoded());
        }
    }

    private static SecretKey loadKey(String filePath) throws IOException {
        byte[] keyBytes = new byte[KEY_SIZE / 8];
        try (FileInputStream fis = new FileInputStream(filePath)) {
            fis.read(keyBytes);
        }
        return new SecretKeySpec(keyBytes, ALGORITHM);
    }

    private static void encrypt(String inputFile, String outputFile, SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        byte[] iv = new byte[cipher.getBlockSize()];
        SecureRandom random = new SecureRandom();
        random.nextBytes(iv);
        IvParameterSpec ivParams = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParams);

        try (FileInputStream fis = new FileInputStream(inputFile);
             FileOutputStream fos = new FileOutputStream(outputFile)) {
            fos.write(iv); // Сохраняем IV в начале файла
            byte[] inputBytes = new byte[64];
            int bytesRead;
            while ((bytesRead = fis.read(inputBytes)) != -1) {
                byte[] outputBytes = cipher.update(inputBytes, 0, bytesRead);
                if (outputBytes != null) {
                    fos.write(outputBytes);
                }
            }
            byte[] outputBytes = cipher.doFinal();
            if (outputBytes != null) {
                fos.write(outputBytes);
            }
        }
    }

    private static void decrypt(String inputFile, String outputFile, SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        try (FileInputStream fis = new FileInputStream(inputFile);
             FileOutputStream fos = new FileOutputStream(outputFile)) {
            byte[] iv = new byte[16]; // Размер IV для AES
            fis.read(iv); // Читаем IV из файла
            IvParameterSpec ivParams = new IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParams);

            byte[] inputBytes = new byte[64];
            int bytesRead;
            while ((bytesRead = fis.read(inputBytes)) != -1) {
                byte[] outputBytes = cipher.update(inputBytes, 0, bytesRead);
                if (outputBytes != null) {
                    fos.write(outputBytes);
                }
            }
            byte[] outputBytes = cipher.doFinal();
            if (outputBytes != null) {
                fos.write(outputBytes);
            }
        }
    }
}

39. Разработать программу нахождения наибольшего общего делителя двух натуральных чисел. Требуется реализовать рекурсивный и без рекурсии варианты. Результат сохранить в MySQL/PostgreSQL. 
package org.example;

//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class Main {

    // Рекурсивный метод для нахождения НОД
    public static int gcdRecursive(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcdRecursive(b, a % b);
    }

    // Итеративный метод для нахождения НОД
    public static int gcdIterative(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // Метод для сохранения результата в базу данных
    public static void saveGCD(int a, int b, int gcd) {
        String url = "jdbc:postgresql://localhost:5432/ex_39";
        String user = "postgres";
        String password = "1";
        String sql = "INSERT INTO gcd_results (number1, number2, gcd) VALUES (?, ?, ?)";

        try (Connection conn = DriverManager.getConnection(url, user, password);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, a);
            pstmt.setInt(2, b);
            pstmt.setInt(3, gcd);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите первое натуральное число: ");
        int a = scanner.nextInt();

        System.out.print("Введите второе натуральное число: ");
        int b = scanner.nextInt();

        // Нахождение НОД рекурсивным методом
        int gcdRec = gcdRecursive(a, b);
        System.out.println("НОД (рекурсивный метод): " + gcdRec);
        saveGCD(a, b, gcdRec);

        // Нахождение НОД итеративным методом
        int gcdIter = gcdIterative(a, b);
        System.out.println("НОД (итеративный метод): " + gcdIter);
        saveGCD(a, b, gcdIter);

        scanner.close();
    }
}


/*
CREATE TABLE gcd_results (
        id SERIAL PRIMARY KEY,
        number1 INT NOT NULL,
        number2 INT NOT NULL,
        gcd INT NOT NULL
);
*/

/*
<dependencies>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.2.20</version> <!-- или последняя версия -->
        </dependency>
    </dependencies>
*/

/*
48, 18, --> 6, 6
*/

40. Напишите программу, которая каждые 5 секунд отображает на экране данные о времени, прошедшем от начала запуска программы, а другой её поток выводит сообщение каждые 7 секунд. Третий поток выводит на экран сообщение каждые 10 секунд. Программа работает одну минуту, затем останавливается. Все результаты после вывода необходимо сохранить в MySQL/PostgreSQL. 
package org.example;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class MultiThreadedLogger {
    private static final String DB_URL = "jdbc:postgresql://localhost:5432/ex_40";
    private static final String USER = "postgres";
    private static final String PASSWORD = "1";

    private static Connection connection;

    public static void main(String[] args) {
        try {
            connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);
            Thread timeLogger = new Thread(new TimeLogger());
            Thread messageLogger = new Thread(new MessageLogger("Message every 7 seconds", 7000));
            Thread anotherMessageLogger = new Thread(new MessageLogger("Another message every 10 seconds", 10000));

            timeLogger.start();
            messageLogger.start();
            anotherMessageLogger.start();

            // Даем потокам поработать 60 секунд
            Thread.sleep(60000);

            // Останавливаем потоки
            timeLogger.interrupt();
            messageLogger.interrupt();
            anotherMessageLogger.interrupt();

            // Ждем завершения потоков
            timeLogger.join();
            messageLogger.join();
            anotherMessageLogger.join();

        } catch (SQLException | InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    static class TimeLogger implements Runnable {
        private long startTime;

        public TimeLogger() {
            this.startTime = System.currentTimeMillis();
        }

        @Override
        public void run() {
            while (!Thread.currentThread().isInterrupted()) {
                long elapsedTime = System.currentTimeMillis() - startTime;
                String message = "Elapsed time: " + (elapsedTime / 1000) + " seconds";
                System.out.println(message);
                saveToDatabase(message);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    static class MessageLogger implements Runnable {
        private final String message;
        private final long interval;

        public MessageLogger(String message, long interval) {
            this.message = message;
            this.interval = interval;
        }

        @Override
        public void run() {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println(message);
                saveToDatabase(message);
                try {
                    Thread.sleep(interval);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private static void saveToDatabase(String message) {
        String sql = "INSERT INTO logs (message) VALUES (?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, message);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

/*
CREATE TABLE logs (
    id SERIAL PRIMARY KEY,
    message TEXT NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
*/

/*
    <dependencies>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.2.20</version>
        </dependency>
    </dependencies>
 */




41. Условие задачи: «Ввести две строки (не менее 50 символов каждая) с клавиатуры. Необходимо вывести на экран две введенных ранее строки, подсчитать и вывести размер длины каждой строки, объединить данные строки в одну, сравнить данные строки и результат сравнения вывести на экран». По данному условию необходимо реализовать программу с интерактивным консольным меню, (т.е. вывод списка действий по цифрам. При этом при нажатии на цифру у нас должно выполняться определенное действие). При этом в программе данные пункты должны называться следующим образом: 
1. Вывести все таблицы из MySQL.
2. Создать таблицу в MySQL.
3. Ввести две строки с клавиатуры, результат сохранить в MySQL с последующим 
выводом в консоль.
4.Подсчитать размер ранее введенных строк, результат сохранить в MySQL с 
последующим выводом в консоль.
5. Объединить две строки в единое целое, результат сохранить в MySQL с последующим 
выводом в консоль.
6. Сравнить две ранее введенные строки, результат сохранить в MySQL с последующим 
выводом в консоль.
7. Сохранить все данные (вышеполученные результаты) из MySQL в Excel и вывести на 
экран. 
42. Написать на основе Spring Boot клиент-серверное приложение MyUser, в котором можно управлять данными пользователей из базы данных через веб-интерфейс: имя, фамилия, возраст, номер группы. База данных может быть любой – MySQL, PostgreSQL и т.д. При этом должна быть доступна возможность добавления/удаления/редактирования пользователей. 
43. Написать на основе Spring Boot Security форму для авторизации и регистрации пользователя. При этом после авторизации пользователя должно быть перенаправление на главную страницу. Главная страница должна содержать запись «Hello World!». При этом до авторизации главная страница не должна быть доступна для пользователя. 
44. Разработать MVC-приложение арифметический калькулятор на основе Spring Boot. Применить шаблонизатор Thymeleaf. Все результаты вычисления должны сохраняться и выводиться из MySQL. 
45.Разработка веб-MVC приложения на основе Spring Boot. Приложение должно генерировать последовательность из 1000 случайных чисел в диапазоне, заданном пользователем, и выводит эти числа на экран и вычисляет их среднее арифметическое. 

